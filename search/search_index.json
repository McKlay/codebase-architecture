{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Table of Contents","text":""},{"location":"#codebase-architecture-designing-for-scale-modularity-and-sanity","title":"Codebase Architecture: Designing for Scale, Modularity, and Sanity","text":""},{"location":"#a-practical-guide-to-structuring-react-fastapi-projects-in-the-age-of-ai","title":"A Practical Guide to Structuring React + FastAPI Projects in the Age of AI","text":""},{"location":"#contents","title":"Contents","text":""},{"location":"#preface","title":"\ud83d\udcd6 Preface","text":"<ul> <li> <p>Why This Book Exists</p> </li> <li> <p>Who Should Read This</p> </li> <li> <p>From Chaos to Clarity: How This Book Was Born</p> </li> <li> <p>What You\u2019ll Learn (and What You Won\u2019t)</p> </li> <li> <p>How to Read This Book (Even If You\u2019re Mid-Project)</p> </li> </ul>"},{"location":"#part-i-foundations","title":"Part I \u2013 Foundations","text":"<p>\u00a0\u00a0\u00a0\u00a0 Chapter 1: Introduction</p> <p>\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01.1 What this book solves?</p> <p>\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01.2 Who this book is for</p> <p>\u00a0\u00a0\u00a0\u00a0 Chapter 2: Why Folder Structure Matters</p> <p>\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a02.1 Anatomy of growing software chaos</p> <p>\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a02.2 Real-world symptoms of bad structure</p> <p>\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a02.3 The role of architecture in scale and collaboration</p> <p>\u00a0\u00a0\u00a0\u00a0 Chapter 3: Modularity vs. Scalability</p> <p>\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a03.1 Definitions and core differences</p> <p>\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a03.2 Why most projects need both</p> <p>\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a03.3 Thinking in layers vs. features</p> <p>\u00a0\u00a0\u00a0\u00a0 Chapter 4: How Structure Impacts Software Quality</p> <p>\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a04.1 Maintainability</p> <p>\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a04.2 Testability</p> <p>\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a04.3 Developer onboarding</p> <p>\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a04.4 Refactoring ease</p> <p>\u00a0\u00a0\u00a0\u00a0 Chapter 5: Core Principles of Architecture</p> <p>\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a05.1 Separation of Concerns</p> <p>\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a05.2 High Cohesion, Low Coupling</p> <p>\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a05.3 DRY and Reusability</p> <p>\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a05.4 Convention over Configuration</p> <p>\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a05.5 Structure as API for teams</p> <p>\u00a0\u00a0\u00a0\u00a0 Chapter 6: Understanding the Stack</p> <p>\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a06.1 Overview of React + Vite (Frontend)</p> <p>\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a06.2 Overview of FastAPI (Backend)</p> <p>\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a06.3 How they communicate (REST, WebSockets, Streaming)</p> <p>\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a06.4 Shared challenges: auth, state sync, rate limiting, API versioning</p>"},{"location":"#part-ii-modularity","title":"Part II \u2013 Modularity","text":"<p>\u00a0\u00a0\u00a0\u00a0 Chapter 7: Modular Architecture Overview</p> <p>\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a07.1 What is modular structure?</p> <p>\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a07.2 MWhen to use it</p> <p>\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a07.3 Benefits vs. drawbacks</p> <p>\u00a0\u00a0\u00a0\u00a0 Chapter 8: Modular Folder Structure for React + Vite</p> <p>\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a08.1 Feature-first organization</p> <p>\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a08.2 Example folder breakdown</p> <p>\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a08.3 Managing component isolation</p> <p>\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a08.4 Organizing hooks, services, and utils within modules</p> <p>\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a08.5 Naming conventions for modular files</p> <p>\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a08.6 Avoiding shared state bleed</p> <p>\u00a0\u00a0\u00a0\u00a0 Chapter 9: Modular Folder Structure for FastAPI</p> <p>\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a09.1 Feature-centric backend design</p> <p>\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a09.2 Organizing routes, schemas, services</p> <p>\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a09.3 Keeping shared logic clean (e.g., OCR, GPT clients, DB connectors)</p> <p>\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a09.4 Handling circular imports</p> <p>\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a09.5 Structuring testable service layers</p> <p>\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a09.6 Dependency injection and inversion</p> <p>\u00a0\u00a0\u00a0\u00a0 Chapter 10: Testing in Modular Projects</p> <p>\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a010.1 Writing tests per module</p> <p>\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a010.2 Shared mock strategies</p> <p>\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a010.3 Organizing test folders and fixtures</p> <p>\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a010.4 Keeping modules independently testable</p>"},{"location":"#part-iii-scalability","title":"Part III \u2013 Scalability","text":"<p>\u00a0\u00a0\u00a0\u00a0 Chapter 11: Scalable Architecture Overview</p> <p>\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a011.1 When modular is not enough</p> <p>\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a011.2 Symptoms of scale pressure</p> <p>\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a011.3 Layered design thinking</p> <p>\u00a0\u00a0\u00a0\u00a0 Chapter 12: Scalable Folder Structure for React + Vite)</p> <p>\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a012.1 Layer-first approach: <code>/api</code>, <code>/services</code>, <code>/hooks</code>, <code>/components</code></p> <p>\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a012.2 Managing cross-feature logic and global state</p> <p>\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a012.3 Shared UI systems and design tokens</p> <p>\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a012.4 Component libraries and scalable styling</p> <p>\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a012.5 Supporting multiple teams on the same codebase</p> <p>\u00a0\u00a0\u00a0\u00a0 Chapter 13: Scalable Folder Structure for FastAPI</p> <p>\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a013.1 Layered backend: <code>/api</code>, <code>/services</code>, <code>/schemas</code>, <code>/core</code>, <code>/infra</code></p> <p>\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a013.2 Clean separation of routers, models, and business logic</p> <p>\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a013.3 Supporting background jobs (e.g., Celery, FastAPI tasks)</p> <p>\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a013.4 Auth, permissions, and role-based modules</p> <p>\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a013.5 Versioned routing and scalable endpoints</p> <p>\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a013.6 Repository pattern for data access</p> <p>\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a013.7 Handling vector DBs and external APIs gracefully</p> <p>\u00a0\u00a0\u00a0\u00a0 Chapter 14: Deploying and Scaling React + FastAPI Projects</p> <p>\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a014.1 Folder structure impact on CI/CD pipelines</p> <p>\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a014.2 Docker best practices for structure</p> <p>\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a014.3 Managing environment variables and secrets</p> <p>\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a014.4 Static files and public assets</p> <p>\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a014.5 Horizontal vs. vertical scaling</p> <p>\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a014.6 Infra as code (IaC) tips for growth</p>"},{"location":"#part-iv-hybrid-and-advanced-techniques","title":"Part IV \u2013 Hybrid and Advanced Techniques","text":"<p>\u00a0\u00a0\u00a0\u00a0 Chapter 15: Hybrid Folder Structures</p> <p>\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a015.1 What hybrid means (modular + scalable)</p> <p>\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a015.2 Use cases for hybridization</p> <p>\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a015.3 Evolving modular apps to scalable ones</p> <p>\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a015.4 Gradual migration strategies</p> <p>\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a015.5 Refactor patterns and heuristics</p> <p>\u00a0\u00a0\u00a0\u00a0 Chapter 16: Monorepos and Shared Logic</p> <p>\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a016.1 When to use a monorepo</p> <p>\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a016.2 Structuring React + FastAPI in one codebase</p> <p>\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a016.3 Sharing types, schemas, and validations</p> <p>\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a016.4 Using pnpm workspaces, Turborepo, or Nx</p> <p>\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a016.5 Versioning strategies for shared logic</p> <p>\u00a0\u00a0\u00a0\u00a0 Chapter 17: Organizing Assets, Tests, and Configuration</p> <p>\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a017.1 Best practices for <code>/assets</code>, <code>/env</code>, <code>/docs</code>, and <code>/configs</code></p> <p>\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a017.2 Feature-based vs. centralized testing</p> <p>\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a017.3 Managing mock data and API fakes</p> <p>\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a017.4 Global configs vs. per-feature config files</p> <p>\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a017.5 Linting, formatting, and pre-commit structuring</p> <p>\u00a0\u00a0\u00a0\u00a0 Chapter 18: Migration Playbook</p> <p>\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a018.1 From flat \u2192 modular \u2192 scalable</p> <p>\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a018.2 Folder audit checklist</p> <p>\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a018.3 Common mistakes and how to resolve them</p> <p>\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a018.4 Refactor-safe conventions</p>"},{"location":"#part-v-case-studies-and-templates","title":"Part V \u2013 Case Studies and Templates","text":"<p>\u00a0\u00a0\u00a0\u00a0 Chapter 19: Case Study: Smart Receipt/Invoice Analyzer</p> <p>\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a019.1 OCR-first modular architecture</p> <p>\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a019.2 GPT pipeline integration</p> <p>\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a019.3 Frontend dynamic table + backend processing</p> <p>\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a019.4 How modular evolved into hybrid</p> <p>\u00a0\u00a0\u00a0\u00a0 Chapter 20: Case Study: Document Intelligence Chatbot</p> <p>\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a020.1 Fully scalable design</p> <p>\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a020.2 Embeddings and vector DBs</p> <p>\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a020.3 Chat UI, streaming, RAG pipeline</p> <p>\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a020.4 React frontend folder \u2192 FastAPI backend folder</p> <p>\u00a0\u00a0\u00a0\u00a0 Chapter21: Case Study: AI-Powered Mockup-to-Code Tool</p> <p>\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a021.1 GPT-driven frontend generator</p> <p>\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a021.2 Image parsing modules</p> <p>\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a021.3 Event and layout-driven architecture</p> <p>\u00a0\u00a0\u00a0\u00a0 Chapter 22: Complete Starter Templates</p> <p>\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a022.1 React + FastAPI Modular Template</p> <p>\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a022.2 React + FastAPI Scalable Template</p> <p>\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a022.3 React + FastAPI Hybrid AI App Template</p> <p>\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a022.4 Folder walk-throughs and clone instructions</p>"},{"location":"#appendices","title":"Appendices","text":"<p>A. Glossary of Terms B. Tools and Libraries Reference C. Recommended Folder Structures (Cheat Sheets) D. Formatter, Linter, and Dev Config Tips E. Further Reading and Resources F. Migration Checklist &amp; Structure Audit Guide</p>"},{"location":"PartIII_overview/","title":"&nbsp;&nbsp; \ud83d\udcd6 Part III: Scalability","text":""},{"location":"PartIII_overview/#part-3-scalability","title":"Part 3: Scalability","text":""},{"location":"PartIII_overview/#overview-from-modular-to-scalable-architecture","title":"Overview: From Modular to Scalable Architecture","text":"<p>\u201cModularity gives you structure. Scalability gives you strategy.\u201d</p>"},{"location":"PartIII_overview/#why-modularity-isnt-enough","title":"Why Modularity Isn\u2019t Enough","text":"<p>Modular architecture is a powerful starting point. It gives you:</p> <ul> <li>Feature isolation</li> <li>Testability</li> <li>Clear developer ownership</li> </ul> <p>But as your app evolves\u2014more features, more shared services, more contributors\u2014you\u2019ll hit structural friction that modularity alone can't solve.</p> <p>That\u2019s when you shift to scalable architecture.</p> <p>Not because modular is wrong. But because:</p> <ul> <li>Modules start depending on shared services</li> <li>Global concerns like auth, logging, or analytics spread across features</li> <li>Your folder structure stops answering the question: How do I grow this app with 10 developers and 100 routes?</li> </ul> <p>Scalability is about evolving your structure to match team scale, system complexity, and domain boundaries.</p>"},{"location":"PartIII_overview/#what-makes-an-architecture-scalable","title":"What Makes an Architecture \u201cScalable\u201d?","text":"<p>A scalable folder structure does four things well:</p> Property Description Separation of layers Clearly splits routing, services, models, and infra Global service integration Supports logging, error handling, AI pipelines, permissions Developer parallelism Allows multiple teams to work without merge conflicts Evolvability You can replace or extend parts (e.g., swap GPT for Claude, or SQL for vector DB) without rewriting half the system <p>It\u2019s not about having more folders. It\u2019s about creating a structure that scales with both technical load and team complexity.</p>"},{"location":"PartIII_overview/#what-changes-when-you-scale","title":"What Changes When You Scale?","text":"Concern Modular Focus Scalable Focus Feature ownership Each module owns everything Global services must be shared cleanly Code reuse Optional and local Mandatory and enforced Testing Unit-first, colocated Unit + integration + CI pipelines Dev velocity 1\u20132 devs/module 2+ teams, overlapping features Cross-cutting concerns Minimal Core (auth, observability, versioning) must be layered App orchestration Simple request\u2192response Background jobs, queues, task orchestration, streams <p>Scalability introduces architectural patterns: services, adapters, repositories, core layers, shared infrastructure.</p> <p>You move from \u201cjust building features\u201d \u2192 to engineering systems.</p>"},{"location":"PartIII_overview/#how-this-part-is-structured","title":"How This Part Is Structured","text":"<p>This part gives you everything you need to transition into a scalable architecture.</p> <p>We\u2019ll walk through:</p>"},{"location":"PartIII_overview/#chapter-11-scalable-architecture-overview","title":"\ud83d\udcd8 Chapter 11: Scalable Architecture Overview","text":"<ul> <li>How to recognize scale pressure in your project</li> <li>When modular breaks down</li> <li>The shift toward layered thinking</li> </ul>"},{"location":"PartIII_overview/#chapter-12-scalable-folder-structure-for-react-vite","title":"\ud83d\udcd8 Chapter 12: Scalable Folder Structure for React + Vite","text":"<ul> <li>Moving from <code>features/</code> to <code>layers/</code> (<code>api/</code>, <code>services/</code>, <code>components/</code>, etc.)</li> <li>Handling cross-feature UI and state</li> <li>Building reusable component libraries</li> <li>Team-oriented React structures</li> </ul>"},{"location":"PartIII_overview/#chapter-13-scalable-folder-structure-for-fastapi","title":"\ud83d\udcd8 Chapter 13: Scalable Folder Structure for FastAPI","text":"<ul> <li>Layering your backend: <code>api/</code>, <code>services/</code>, <code>schemas/</code>, <code>infra/</code>, <code>core/</code></li> <li>Handling async background jobs (e.g., Celery, FastAPI background tasks)</li> <li>Auth, role-based access, and scalable routing</li> <li>Repository pattern and clean architecture principles</li> <li>How to structure integrations with vector DBs, LLM clients, and queues</li> </ul>"},{"location":"PartIII_overview/#chapter-14-deploying-and-scaling-react-fastapi-projects","title":"\ud83d\udcd8 Chapter 14: Deploying and Scaling React + FastAPI Projects","text":"<ul> <li>Folder structure impact on Docker, CI/CD, and deployment flow</li> <li>Secrets, environment configs, and managing <code>.env</code> files across environments</li> <li>Asset management and public files</li> <li>Scaling horizontally vs. vertically</li> <li>How folder structure supports Infrastructure-as-Code (IaC)</li> </ul>"},{"location":"PartII_overview/","title":"&nbsp;&nbsp; \ud83d\udcd6 Part II: Modularity","text":""},{"location":"PartII_overview/#part-2-modularity","title":"Part 2: Modularity","text":"<p>\u201cModularity isn\u2019t about folders. It\u2019s about boundaries, ownership, and change without fear.\u201d</p> <p>In Part 2, we move from why structure matters to how modularity delivers clarity, flexibility, and velocity\u2014especially in the early and mid-stages of software development.</p> <p>Whether you're building an OCR-to-GPT receipt analyzer or a chatbot that extracts meaning from legal documents, the principle remains the same:</p> <p>Organize by what changes together. Isolate what changes independently.</p> <p>That\u2019s modularity.</p> <p>You don\u2019t just want to build features\u2014you want to build self-contained units of value, each with their own logic, tests, and UI.</p> <p>This part teaches you how to design for that.</p>"},{"location":"PartII_overview/#why-modularity","title":"Why Modularity?","text":"<p>A modular folder structure helps you:</p> <ul> <li>Keep features isolated and independently testable</li> <li>Onboard new developers faster with clearer ownership</li> <li>Avoid cross-feature bugs and naming collisions</li> <li>Grow prototypes into real products without rewrites</li> </ul> <p>It\u2019s ideal for:</p> <ul> <li>Solo developers or small teams</li> <li>MVPs and internal tools</li> <li>Projects still shaping their domain boundaries</li> </ul> <p>Modularity is not a shortcut\u2014it's a strategy for maintainable independence.</p>"},{"location":"PartII_overview/#what-youll-learn-in-part-2","title":"What You'll Learn in Part 2","text":"Chapter Key Idea 7. Modular Architecture Overview What modular structure means in practice, and when to choose it. 8. Modular Folder Structure for React + Vite Feature-first structure, folder anatomy, and keeping UI concerns scoped. 9. Modular Folder Structure for FastAPI Designing modular backends with clean services, routers, and schemas. 10. Testing in Modular Projects How to test per module, avoid global mock sprawl, and keep features testable in isolation."},{"location":"PartII_overview/#modularity-simplicity","title":"Modularity \u2260 Simplicity","text":"<p>Modular apps often feel simpler because they reduce inter-feature dependency\u2014but under the hood, they demand thoughtful composition.</p> <p>This part doesn\u2019t just show you the shape of a modular app. It teaches you how to think modularly: which boundaries matter, how to organize logic per feature, and how to evolve structure as complexity grows.</p> <p>By the end of Part 2, you\u2019ll be able to:</p> <ul> <li>Structure both React and FastAPI projects using the feature-first philosophy</li> <li>Keep services, hooks, routes, and logic inside each feature</li> <li>Prevent shared-state bleed and keep testability high</li> <li>Prepare for the day when modular won\u2019t be enough (spoiler: that\u2019s Part 3)</li> </ul>"},{"location":"PartIV_overview/","title":"&nbsp;&nbsp; \ud83d\udcd6 Part IV: Hybrid and Advanced Techniques","text":""},{"location":"PartIV_overview/#part-4-hybrid-and-advanced-techniques","title":"Part 4: Hybrid and Advanced Techniques","text":"<p>\u201cNo structure lasts forever. Great systems evolve without losing their soul.\u201d</p> <p>By now, you\u2019ve seen how modular and scalable folder structures serve different stages of a project\u2019s lifecycle. But what happens when your application demands both?</p> <ul> <li>When features are growing fast but still need clean separation</li> <li>When shared infrastructure is becoming too complex for repetition</li> <li>When teams want autonomy and consistency</li> </ul> <p>That\u2019s where hybrid architecture comes in.</p> <p>Part 4 explores the techniques used by production-grade AI applications\u2014where modular thinking meets layered design, where multiple apps share common logic, and where flexibility coexists with scale.</p> <p>You\u2019ll learn how to combine approaches, organize shared code, and prepare for long-term growth with confidence.</p>"},{"location":"PartIV_overview/#why-hybrid","title":"Why Hybrid?","text":"<p>Hybrid structures give you the best of both worlds:</p> <ul> <li>\u2705 Feature isolation (modular)</li> <li>\u2705 Shared service layers and infrastructure (scalable)</li> <li>\u2705 Monorepo-friendly layout for AI, microservices, or full-stack apps</li> <li>\u2705 Clear paths for collaboration across frontend, backend, and shared packages</li> </ul> <p>They shine in projects like:</p> <ul> <li>AI-first products (OCR + GPT + vector DB + RAG)</li> <li>Cross-team platforms with reusable modules</li> <li>Systems with multiple pipelines or domains under one roof</li> </ul>"},{"location":"PartIV_overview/#what-youll-learn-in-part-4","title":"What You'll Learn in Part 4","text":"Chapter Key Idea 15. Hybrid Folder Structures When and how to merge modular and scalable thinking into a cohesive design. 16. Monorepos and Shared Logic Structuring React + FastAPI in a unified repo, and sharing types, validation, and utils. 17. Organizing Assets, Tests, and Configuration Patterns for /assets, /env, /docs, and /configs that scale cleanly. 18. Migration Playbook A safe path from flat \u2192 modular \u2192 scalable \u2192 hybrid. Includes audits, heuristics, and refactor plans."},{"location":"PartIV_overview/#why-this-section-matters","title":"Why This Section Matters","text":"<p>Every long-lived project eventually outgrows its initial structure. But most fail because they don\u2019t plan for that growth.</p> <p>Hybrid architecture helps you transition without disruption. It helps you recognize patterns, detect scaling pain early, and make structure a living part of your product\u2014not an afterthought.</p> <p>This part is your roadmap for evolution. It\u2019s how prototypes become platforms.</p>"},{"location":"PartI_overview/","title":"&nbsp;&nbsp; \ud83d\udcd6 Part I: Foundations","text":""},{"location":"PartI_overview/#part-1-foundations","title":"Part 1: Foundations","text":"<p>\u201cBefore you shape the structure, let the structure shape your thinking.\u201d</p> <p>Before diving into folder names and layouts, we begin where all strong architecture does: with understanding. Part 1 is about building a mental model for why folder structure matters\u2014not just in technical terms, but in terms of workflow, scalability, and developer sanity.</p> <p>Too often, folder decisions are treated as cosmetic\u2014\"just preferences.\" But the moment a project grows past 3 features or 2 contributors, structure becomes the invisible architecture that either holds your system together or lets it fracture under pressure.</p> <p>This section lays the groundwork by exploring:</p> <ul> <li>Why structure is not a personal preference but a team contract</li> <li>How bad folder practices lead to bugs, confusion, and duplication</li> <li>What modularity and scalability actually mean (and how they differ)</li> <li>Which architectural principles give structure lasting power</li> <li>How your stack (React + Vite + FastAPI) influences structural decisions</li> </ul>"},{"location":"PartI_overview/#what-youll-learn-in-part-1","title":"What You'll Learn in Part 1","text":"Chapter Key Idea 1. Introduction Why this book exists, who it\u2019s for, and what it will change in how you build. 2. Why Folder Structure Matters From chaotic codebases to mental overhead\u2014real stories of structure gone wrong. 3. Modularity vs. Scalability Definitions, trade-offs, and why you need both at different stages. 4. How Structure Impacts Software Quality Maintainability, testability, onboarding\u2014structure is the silent driver. 5. Core Principles of Architecture The foundational concepts behind great structure: SoC, DRY, cohesion, and more. 6. Understanding the Stack The architectural assumptions and constraints of React + FastAPI, and how they shape folder strategy."},{"location":"PartI_overview/#why-this-section-matters","title":"Why This Section Matters","text":"<p>You don\u2019t just need folders that \"make sense.\" You need folders that scale with your product, align with your team, and stand the test of change.</p> <p>By the end of Part 1, you\u2019ll see folder structure not as a rigid decision\u2014but as a living system that reflects the philosophy behind your software.</p> <p>Let\u2019s begin with the problem that sparked this book: \u201cWhere do I put this file?\u201d</p>"},{"location":"PartV_overview/","title":"&nbsp;&nbsp; \ud83d\udcd6 Part V: Case Studies and Templates","text":""},{"location":"PartV_overview/#part-5-case-studies-and-templates","title":"Part 5: Case Studies and Templates","text":"<p>\u201cArchitecture is not just theory\u2014it\u2019s tested in the trenches.\u201d</p> <p>After all the principles, patterns, and folder diagrams, it\u2019s time to see structure in motion.</p> <p>Part 5 is where everything comes together\u2014real applications, real constraints, and real decisions. You\u2019ll walk through complete project architectures, each grounded in practical needs like OCR pipelines, GPT integration, frontend rendering, RAG workflows, and scalable deployment.</p> <p>This isn\u2019t just about folder layout. It\u2019s about the why behind every structural decision:</p> <ul> <li>Why one feature was split into its own module</li> <li>Why a service was abstracted into a core layer</li> <li>Why certain logic was centralized vs. colocated</li> </ul> <p>Each case study is annotated, mapped, and paired with downloadable templates to help you build your own production-grade apps faster.</p>"},{"location":"PartV_overview/#what-makes-these-case-studies-special","title":"What Makes These Case Studies Special?","text":"<p>Each project:</p> <ul> <li>Was designed with both AI workflows and scalable architecture in mind</li> <li>Shows how to evolve from modular \u2192 hybrid \u2192 scalable</li> <li>Is accompanied by a starter template, folder walkthrough, and real-world insights</li> </ul>"},{"location":"PartV_overview/#what-youll-learn-in-part-5","title":"What You'll Learn in Part 5","text":"Chapter Key Idea 19. Case Study: Smart Receipt/Invoice Analyzer A modular-first design featuring OCR, GPT parsing, and dynamic frontend rendering. Traces the path to hybrid structure. 20. Case Study: Document Intelligence Chatbot A scalable AI system using embeddings, RAG, streaming, and layered backend services. Highlights clear separation of vector logic, UI, and GPT prompts. 21. Case Study: AI-Powered Mockup-to-Code Tool A modular + scalable hybrid. Uses image upload, GPT-based UI generation, and structured API/service layers. 22. Complete Starter Templates Prebuilt React + FastAPI templates for Modular, Scalable, and Hybrid architectures. Includes folder walkthroughs, README guides, and <code>npx</code>-ready cloning instructions."},{"location":"PartV_overview/#included-templates","title":"Included Templates","text":"Template Stack Description Modular Starter React + FastAPI Feature-based folder setup, ideal for early-stage apps or MVPs Scalable Starter React + FastAPI Layered architecture, great for larger apps and multi-team dev Hybrid AI Template React + FastAPI + GPT + pgvector Real-world GPT + vector DB integration with modular RAG flow"},{"location":"PartV_overview/#why-this-section-matters","title":"Why This Section Matters","text":"<p>Theory fades when deadlines loom and bugs creep in.</p> <p>These case studies show how to scale intentionally:</p> <ul> <li>When to refactor and why</li> <li>How structure accelerates or hinders growth</li> <li>How modularity, scalability, and AI integration coexist in production</li> </ul> <p>By the end of this section, you\u2019ll be able to:</p> <ul> <li>Reverse-engineer any folder structure with confidence</li> <li>Use ready-made templates to jumpstart your own stack</li> <li>Evolve your project based on the same patterns used by AI-native teams</li> </ul>"},{"location":"Preface/","title":"&nbsp; Preface","text":""},{"location":"Preface/#why-this-book-exists","title":"Why This Book Exists","text":"<p>Software projects don\u2019t collapse under the weight of code\u2014they collapse under the weight of chaos. As applications grow in complexity, with more features, services, and contributors added, one often-overlooked factor becomes critical: folder structure.</p> <p>This book was written with one goal: to help developers build clean, scalable folder structures for modern full-stack applications. Whether you're launching a prototype or scaling a mature product, clear organization is a superpower.</p> <p>The technologies we focus on\u2014React + Vite for the frontend and FastAPI for the backend\u2014are fast, modular, and popular among startup teams and solo builders. But the core ideas apply well beyond them. This isn\u2019t just about frameworks. It\u2019s about a way of thinking.</p>"},{"location":"Preface/#who-should-read-this","title":"Who Should Read This","text":"<p>This book is for:</p> <ul> <li>Full-stack developers who want to bring clarity and maintainability to their project architecture.</li> <li>Startup engineers and technical co-founders designing codebases that will scale with teams and users.</li> <li>Software architects and tech leads looking to standardize patterns and speed up onboarding across projects.</li> <li>Self-taught developers tired of messy repos and ready to adopt a more thoughtful design philosophy.</li> </ul> <p>If you\u2019ve ever inherited a tangled codebase and thought, \"There has to be a better way to structure this,\"\u2014this book is for you.</p>"},{"location":"Preface/#from-chaos-to-clarity-how-this-book-was-born","title":"From Chaos to Clarity: How This Book Was Born","text":"<p>Over years of building production apps, I noticed a pattern: tech debt wasn\u2019t coming from bad code\u2014it was coming from disorganized code.</p> <p>Every time we added a new feature, onboarded a new dev, or tried to refactor a monolith into services, it was the folder structure that either helped us move faster\u2014or slowed us to a crawl.</p> <p>So I started documenting what worked. How teams naturally grouped logic. Where bugs tended to cluster. What folder conventions made onboarding effortless. I combined that with insights from AI-first apps I\u2019ve built\u2014like smart document parsers and layout-to-code tools\u2014and turned it into a repeatable system.</p> <p>That system became this book.</p>"},{"location":"Preface/#what-youll-learn-and-what-you-wont","title":"What You\u2019ll Learn (and What You Won\u2019t)","text":"<p>You will learn:</p> <ul> <li>How to design a modular, scalable folder structure for React + Vite and FastAPI apps.</li> <li>How to separate concerns clearly between features, services, APIs, and shared logic.</li> <li>How to handle growing teams, refactoring, and platform evolution with minimal friction.</li> <li>How to use real-world templates and patterns drawn from production-grade AI tools.</li> </ul> <p>You will not find:</p> <ul> <li>Deep dives into the internals of React or FastAPI.</li> <li>Framework-agnostic advice that avoids implementation details.</li> <li>One-size-fits-all folder layouts without context or trade-offs.</li> </ul> <p>This is a builder\u2019s guide to structuring real apps\u2014not a generic architecture manifesto.</p>"},{"location":"Preface/#how-to-read-this-book-even-if-youre-mid-project","title":"How to Read This Book (Even If You\u2019re Mid-Project)","text":"<p>Each chapter includes:</p> <ul> <li>Folder Diagrams: Visual layouts of project structures at different stages.</li> <li>Code Walkthroughs: Real examples from React and FastAPI codebases.</li> <li>Trade-Off Analysis: Pros and cons of different structural choices.</li> <li> <p>Case Studies: Patterns used in AI-powered apps like:</p> <ul> <li>Smart receipt and invoice analyzers</li> <li>Layout-to-code vision tools</li> <li>GPT + vector DB chatbots</li> </ul> </li> </ul> <p>You don\u2019t need to start from scratch to benefit. Even if you\u2019re in the middle of a project, this book can help you reorient and future-proof what you\u2019ve already built.</p> <p>Because in software, it\u2019s not just what you build that matters\u2014 It\u2019s how you build it.</p> <p>\u2014 Clay</p>"},{"location":"appendices/","title":"&nbsp;&nbsp; \ud83d\udcd6 Appendices","text":""},{"location":"appendices/#appendix","title":"Appendix","text":""},{"location":"appendices/#a-glossary-of-terms","title":"A. Glossary of Terms","text":"Term Definition Modular Structure Organizing folders by features or domains, where each contains its own logic, UI, tests, and services. Promotes isolation and encapsulation. Scalable Structure Organizing folders by layers (api, services, models, infra, etc.) to support large teams, shared logic, and consistent abstraction boundaries. Hybrid Structure A blend of modular (per feature) and scalable (per layer) architecture. Often starts modular and evolves into scalable. Feature Slice A complete vertical set of files (UI, logic, tests) related to one business domain. Service Layer A dedicated layer for reusable business logic, utilities, or model abstraction. Keeps features lightweight and testable. Separation of Concerns Design principle that promotes separating code based on distinct responsibilities (UI, logic, data, etc.) High Cohesion Keeping related pieces of logic close together to improve maintainability and understanding. Low Coupling Reducing dependencies between components to ensure changes in one don\u2019t break others. RAG Retrieval-Augmented Generation. Combines vector search with GPT-style generation to create grounded, document-aware answers."},{"location":"appendices/#b-tools-and-libraries-reference","title":"B. Tools and Libraries Reference","text":""},{"location":"appendices/#frontend","title":"Frontend","text":"<ul> <li>React \u2013 Core frontend framework</li> <li>Vite \u2013 Lightning-fast dev server and bundler</li> <li>Tailwind CSS \u2013 Utility-first styling</li> <li>Zustand / Redux \u2013 State management</li> <li>React Query / SWR \u2013 Async data hooks</li> <li>Framer Motion \u2013 Animations</li> <li>React Router v6 \u2013 Routing</li> </ul>"},{"location":"appendices/#backend","title":"Backend","text":"<ul> <li>FastAPI \u2013 Modern, async Python API framework</li> <li>Pydantic \u2013 Data validation via schemas</li> <li>Uvicorn \u2013 FastAPI ASGI server</li> <li>Tortoise ORM / SQLModel / SQLAlchemy \u2013 DB layers</li> <li>Celery \u2013 Background task manager</li> </ul>"},{"location":"appendices/#ainlp","title":"AI/NLP","text":"<ul> <li>OpenAI (GPT) \u2013 Chat/completion APIs</li> <li>HuggingFace Transformers \u2013 Custom or local LLMs</li> <li>pgvector + Supabase \u2013 Vector storage and similarity search</li> <li>Tesseract / PaddleOCR \u2013 OCR engines</li> </ul>"},{"location":"appendices/#c-recommended-folder-structures-cheat-sheets","title":"C. Recommended Folder Structures (Cheat Sheets)","text":""},{"location":"appendices/#modular-fastapi-per-feature","title":"Modular FastAPI (per-feature)","text":"<pre><code>app/\n\u2514\u2500\u2500 features/\n    \u251c\u2500\u2500 chat/\n    \u2502   \u251c\u2500\u2500 routes.py\n    \u2502   \u251c\u2500\u2500 services.py\n    \u2502   \u2514\u2500\u2500 schemas.py\n</code></pre>"},{"location":"appendices/#scalable-fastapi-per-layer","title":"Scalable FastAPI (per-layer)","text":"<pre><code>app/\n\u251c\u2500\u2500 api/\n\u251c\u2500\u2500 services/\n\u251c\u2500\u2500 schemas/\n\u251c\u2500\u2500 core/\n\u251c\u2500\u2500 vectorstore/\n</code></pre>"},{"location":"appendices/#react-modular","title":"React Modular","text":"<pre><code>src/\n\u2514\u2500\u2500 features/\n    \u251c\u2500\u2500 chat/\n    \u2502   \u251c\u2500\u2500 ChatUI.tsx\n    \u2502   \u251c\u2500\u2500 chatSlice.ts\n    \u2502   \u251c\u2500\u2500 hooks.ts\n    \u2502   \u2514\u2500\u2500 chatService.ts\n</code></pre>"},{"location":"appendices/#react-scalable","title":"React Scalable","text":"<pre><code>src/\n\u251c\u2500\u2500 components/\n\u251c\u2500\u2500 hooks/\n\u251c\u2500\u2500 services/\n\u251c\u2500\u2500 shared/\n</code></pre>"},{"location":"appendices/#d-formatter-linter-and-dev-config-tips","title":"D. Formatter, Linter, and Dev Config Tips","text":"Purpose Tool Config File JavaScript Linting <code>ESLint</code> <code>.eslintrc.json</code> Code Formatting <code>Prettier</code> <code>.prettierrc</code> Python Linting <code>ruff</code> <code>pyproject.toml</code> Python Formatting <code>black</code> <code>pyproject.toml</code> Pre-commit Hooks <code>pre-commit</code> <code>.pre-commit-config.yaml</code> <p>\ud83d\udca1 Tip: Use Husky (JS) or <code>pre-commit</code> (Python) to enforce consistency before commits.</p>"},{"location":"appendices/#e-further-reading-and-resources","title":"E. Further Reading and Resources","text":"<ul> <li>Clean Architecture \u2013 Robert C. Martin</li> <li>Designing Software Architectures \u2013 Humberto Cervantes</li> <li>FastAPI Documentation \u2013 https://fastapi.tiangolo.com</li> <li>React App Structure Best Practices \u2013 Kent C. Dodds</li> <li>Microservices vs Monoliths \u2013 ThoughtWorks Tech Radar</li> <li>Supabase Docs \u2013 https://supabase.com/docs</li> <li>AI App Examples (LangChain, RAG) \u2013 https://github.com/hwchase17/langchain</li> </ul>"},{"location":"appendices/#f-migration-checklist-structure-audit-guide","title":"F. Migration Checklist &amp; Structure Audit Guide","text":""},{"location":"appendices/#migration-checklist","title":"Migration Checklist","text":"<ul> <li>[ ] Identify duplicated logic (move to <code>services/</code>)</li> <li>[ ] Audit cross-feature dependencies (refactor to shared)</li> <li>[ ] Move config/env to <code>core/</code> or <code>.env</code>-based loaders</li> <li>[ ] Restructure tests to mirror feature or layer</li> <li>[ ] Document folder responsibilities in a <code>README.md</code></li> </ul>"},{"location":"appendices/#structure-audit-questions","title":"Structure Audit Questions","text":"<ul> <li>Are components tightly scoped to a domain?</li> <li>Is cross-feature logic reusable or duplicated?</li> <li>Can new developers find what they need in &lt;5 seconds?</li> <li>Are routes, logic, and models clearly separated?</li> <li>Can you test a module in isolation?</li> <li>Are environments easy to switch between (dev, staging, prod)?</li> </ul>"},{"location":"appendices/#closing-words","title":"\ud83c\udf89 Closing Words","text":"<p>A good folder structure is not set in stone\u2014but it is intentional. It evolves with your team, your product, and your ambition.</p> <p>Structure isn\u2019t just about where files live. It\u2019s about how people think, collaborate, and build things together.  </p> <p>So build for clarity. Build for scale. Build for the next developer\u2014including future-you.</p> <p>\u2014 Clay Mark Sarte</p>"},{"location":"chapter1/","title":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Chapter 1","text":""},{"location":"chapter1/#part-1-foundations","title":"Part 1: Foundations","text":""},{"location":"chapter1/#1-introduction","title":"1. Introduction","text":"<p>\u201cWhere should this file go?\u201d If you\u2019ve asked this more than once, you already understand the problem.</p>"},{"location":"chapter1/#what-this-book-solves","title":"What This Book Solves","text":"<p>Software projects don\u2019t break because of bad code\u2014they break because of bad organization. Over time, folders swell, files become god-objects, routes scatter across the codebase, and onboarding a new developer feels like throwing them into a jungle with no map.</p> <p>This book exists to solve a deceptively simple\u2014but universally experienced\u2014problem: How do we structure our folders so that we can keep shipping, growing, and collaborating\u2014without drowning in chaos?</p> <p>By the time you're juggling React components, custom hooks, backend APIs, embeddings, OCR pipelines, and AI workflows all in one product, structure stops being a nice-to-have. It becomes the backbone of development velocity.</p> <p>Whether you're building:</p> <ul> <li>a solo MVP using GPT-4,</li> <li>an internal tool integrating FastAPI and vector search,</li> <li>or a production-grade AI platform with multiple teams...</li> </ul> <p>The same architectural question echoes in every room:</p> <p>How do we make this sustainable?</p> <p>This book answers that question through real patterns, practical examples, and clear folder strategies.</p>"},{"location":"chapter1/#who-this-book-is-for","title":"Who This Book Is For","text":"<p>If you\u2019ve ever:</p> <ul> <li>Lost time hunting for a file you wrote last week,</li> <li>Duplicated logic because you couldn't find or reuse existing code,</li> <li>Onboarded a new teammate only to get buried in Slack questions like \u201cWhere\u2019s the <code>InvoiceService</code> defined again?\u201d,</li> <li>Or hit scaling limits because your flat folder structure couldn\u2019t handle the complexity...</li> </ul> <p>Then this book is for you.</p> <p>We wrote this for:</p> <ul> <li>Frontend developers using React + Vite who want clean component, hook, and API separation</li> <li>Backend engineers building with FastAPI who need to balance route clarity with modular service logic</li> <li>AI engineers and full-stack devs handling embeddings, GPT calls, and real-time pipelines</li> <li>Tech leads who care about developer experience, onboarding, and long-term maintainability</li> <li>Startup builders who want to scale without rewriting half their app structure later</li> </ul> <p>This is not a book about \u201chow to code\u201d\u2014you already know how to write React and Python. This is about the higher-order concern:</p> <p>How to architect your project so that your code, your team, and your ideas can scale together.</p>"},{"location":"chapter1/#what-to-expect","title":"What to Expect","text":"<p>This book is structured around a journey\u2014from foundational principles, to modular strategies, to scalable architectures, and finally to real-world hybrid patterns.</p> <p>We start with core ideas:</p> <ul> <li>What makes a folder structure good or bad?</li> <li>Why is modularity different from scalability?</li> <li>How do principles like \u201cseparation of concerns\u201d and \u201cconvention over configuration\u201d play out in actual file layouts?</li> </ul> <p>Then we move into:</p> <ul> <li>Part 2: Modularity \u2014 where you\u2019ll learn how to keep features isolated and maintainable in both React and FastAPI</li> <li>Part 3: Scalability \u2014 where modular boundaries give way to layered, team-oriented architectures</li> <li>Part 4: Hybrid and Advanced Techniques \u2014 where you\u2019ll discover how real-world systems combine modular and scalable patterns, and how to organize monorepos, shared logic, assets, and CI/CD-friendly folders</li> <li>Part 5: Case Studies and Templates \u2014 where we walk through complete examples like document intelligence chatbots and vision-to-code AI tools</li> </ul> <p>Each section is filled with structure diagrams, folder examples, decision trade-offs, and templates you can copy and adapt.</p>"},{"location":"chapter1/#what-this-book-doesnt-do","title":"What This Book Doesn\u2019t Do","text":"<p>This book won\u2019t:</p> <ul> <li>Teach you React or FastAPI from scratch.</li> <li>Explain how to write unit tests or connect to databases.</li> <li>Dive deep into low-level compiler or container internals.</li> </ul> <p>Instead, it assumes you already know how to build things\u2014and now you want to build them right.</p>"},{"location":"chapter1/#final-word-before-we-begin","title":"Final Word Before We Begin","text":"<p>This book is not opinionated for the sake of opinion. Every structure, every pattern, and every rule we propose was shaped by the real tension between elegance and pragmatism.</p> <p>There is no one-size-fits-all folder layout\u2014but there are timeless principles and proven paths.</p> <p>Our goal is simple:</p> <p>Help you go from \u201cWhere do I put this file?\u201d to \u201cEveryone knows exactly where to look.\u201d</p> <p>Let\u2019s begin.</p>"},{"location":"chapter10/","title":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Chapter 10","text":""},{"location":"chapter10/#part-2-modularity","title":"Part 2: Modularity","text":""},{"location":"chapter10/#10-testing-in-modular-projects","title":"10. Testing in Modular Projects","text":"<p>\u201cA module without a test is a feature waiting to break.\u201d</p>"},{"location":"chapter10/#why-testing-should-be-modular-too","title":"Why Testing Should Be Modular, Too","text":"<p>You can\u2019t have truly modular code unless your tests are modular as well.</p> <p>Testing isn't just about coverage numbers or CI checks. It's about local confidence:</p> <ul> <li>Can I safely refactor this GPT parser?</li> <li>Will changes in <code>upload/</code> break <code>chatbot/</code>?</li> <li>Can a new dev test this module in isolation?</li> </ul> <p>In modular projects, your tests should mirror the folder structure of your features\u2014unit by unit, hook by hook, service by service.</p>"},{"location":"chapter10/#testing-patterns-for-modular-projects","title":"Testing Patterns for Modular Projects","text":"<p>Let\u2019s break testing into four practical layers:</p> Type Goal Where it lives Unit Tests Validate a single function/component Inside <code>__tests__/</code> per feature Integration Tests Validate interaction between internal parts Inside <code>__tests__/</code> or root <code>tests/</code> API Tests Hit real or mock endpoints Root <code>tests/</code> or Postman/Playwright collection E2E Tests Simulate real user flows External repo or <code>/e2e/</code> subfolder"},{"location":"chapter10/#recommended-folder-structure-for-tests","title":"Recommended Folder Structure for Tests","text":"<p>We recommend the hybrid approach:</p> <pre><code>project/\n\u251c\u2500\u2500 frontend/\n\u2502   \u2514\u2500\u2500 src/\n\u2502       \u251c\u2500\u2500 chatbot/\n\u2502       \u2502   \u251c\u2500\u2500 components/\n\u2502       \u2502   \u2514\u2500\u2500 __tests__/\n\u2502       \u2514\u2500\u2500 shared/\n\u2502           \u2514\u2500\u2500 test_helpers/\n\u251c\u2500\u2500 backend/\n\u2502   \u2514\u2500\u2500 app/\n\u2502       \u251c\u2500\u2500 invoice/\n\u2502       \u2502   \u251c\u2500\u2500 services/\n\u2502       \u2502   \u2514\u2500\u2500 __tests__/\n\u2502       \u2514\u2500\u2500 shared/\n\u2502           \u2514\u2500\u2500 test_helpers/\n\u251c\u2500\u2500 tests/             # (root-level)\n\u2502   \u251c\u2500\u2500 test_api_chatbot.py     # Integration/API tests\n\u2502   \u2514\u2500\u2500 test_upload_flow.py     # Cross-feature behavior\n</code></pre> <p>This gives you local testability + global traceability.</p>"},{"location":"chapter10/#react-writing-tests-per-module","title":"React: Writing Tests Per Module","text":"<p>Use tools like <code>vitest</code>, <code>jest</code>, or <code>react-testing-library</code>.</p>"},{"location":"chapter10/#inside-a-feature-module","title":"Inside a feature module:","text":"<pre><code>chatbot/\n\u251c\u2500\u2500 components/\n\u2502   \u2514\u2500\u2500 ChatInput.tsx\n\u251c\u2500\u2500 __tests__/\n\u2502   \u2514\u2500\u2500 ChatInput.test.tsx\n</code></pre> <pre><code>// ChatInput.test.tsx\nimport { render, screen } from \"@testing-library/react\";\nimport ChatInput from \"../components/ChatInput\";\n\ntest(\"renders input box\", () =&gt; {\n  render(&lt;ChatInput /&gt;);\n  expect(screen.getByPlaceholderText(\"Ask something...\")).toBeInTheDocument();\n});\n</code></pre>"},{"location":"chapter10/#shared-test-helpers","title":"Shared test helpers:","text":"<pre><code>shared/test_helpers/\n\u251c\u2500\u2500 mockSession.ts\n\u251c\u2500\u2500 testWrapper.tsx\n</code></pre> <p>Use these to DRY up test scaffolding, especially for:</p> <ul> <li>Auth context</li> <li>Global providers</li> <li>Routing mocks</li> </ul>"},{"location":"chapter10/#fastapi-writing-tests-per-feature","title":"FastAPI: Writing Tests Per Feature","text":"<p>Use <code>pytest</code>, <code>httpx.AsyncClient</code>, and FastAPI\u2019s <code>TestClient</code>.</p>"},{"location":"chapter10/#example-testing-gpt-logic-in-chatbot","title":"Example: Testing GPT logic in <code>chatbot/</code>","text":"<pre><code>chatbot/\n\u251c\u2500\u2500 services/\n\u2502   \u2514\u2500\u2500 chat_service.py\n\u251c\u2500\u2500 __tests__/\n\u2502   \u2514\u2500\u2500 test_chat_service.py\n</code></pre> <pre><code>from chatbot.services.chat_service import stream_response\n\ndef test_streaming_chunks_return_data():\n    prompt = {\"message\": \"Hello\"}\n    chunks = list(stream_response(prompt))\n    assert len(chunks) &gt; 0\n</code></pre> <p>You can also mock GPT by injecting a fake service:</p> <pre><code># shared/test_helpers/mocks.py\nclass FakeGPT:\n    def complete(self, prompt):\n        return \"This is a mock response\"\n</code></pre>"},{"location":"chapter10/#keeping-modules-independently-testable","title":"Keeping Modules Independently Testable","text":"<p>Key goals:</p> <ul> <li>Each module runs its own tests independently</li> <li>No test reaches into another feature's internals</li> <li>Shared mocks and utilities are reused (but not over-abstracted)</li> </ul> <p>Modular testability ensures:</p> <ul> <li>You can deploy or validate a feature in isolation</li> <li>CI/CD pipelines can run partial tests on changed modules only</li> <li>Refactoring is safe and scoped</li> </ul>"},{"location":"chapter10/#mocking-strategies","title":"Mocking Strategies","text":"Target Strategy GPT, OCR, External APIs Fake classes in <code>shared/test_helpers/</code> FastAPI dependencies Use <code>Depends()</code> and override in tests React context / stores Wrap with custom <code>TestProvider.tsx</code> Hooks Mock inside <code>jest.mock()</code> or inject dependencies manually <p>Your tests should not rely on real API keys, internet calls, or production databases.</p>"},{"location":"chapter10/#toolchain-recommendations","title":"Toolchain Recommendations","text":"Stack Suggested Tools React Vitest, React Testing Library, Playwright (E2E) FastAPI Pytest, HTTPX, TestClient, Faker Fullstack Playwright, Postman/Newman, Docker Compose for local testing CI/CD GitHub Actions + <code>pytest</code>/<code>vitest</code> runners with coverage thresholds"},{"location":"chapter10/#automating-modular-test-discovery-in-ci","title":"Automating Modular Test Discovery in CI","text":"<p>To speed up CI:</p> <ol> <li>Detect changed paths using <code>git diff</code></li> <li> <p>Map changed folders to test scopes:</p> </li> <li> <p><code>frontend/src/chatbot/</code> \u2192 run <code>vitest</code> only on <code>chatbot/</code></p> </li> <li><code>backend/app/invoice/</code> \u2192 run <code>pytest</code> on <code>invoice/__tests__/</code></li> </ol> <p>Optional: Use <code>tox</code>, <code>pytest-split</code>, or Nx if in a monorepo.</p>"},{"location":"chapter10/#summary-modular-testing-principles","title":"Summary: Modular Testing Principles","text":"Principle Practice Local testing per module Place <code>__tests__/</code> inside each feature folder Shared mock reuse Store fake services and wrappers in <code>shared/test_helpers/</code> No cross-feature imports Each test should stay inside its domain API and integration tests Put in root <code>tests/</code> folder or external suite CI optimization Detect changes and test only affected modules"},{"location":"chapter11/","title":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Chapter 11","text":""},{"location":"chapter11/#part-3-scalability","title":"Part 3: Scalability","text":""},{"location":"chapter11/#11-scalable-architecture-overview","title":"11. Scalable Architecture Overview","text":"<p>\u201cYou don\u2019t scale by adding more code. You scale by changing how code connects.\u201d</p>"},{"location":"chapter11/#when-modular-isnt-enough","title":"When Modular Isn\u2019t Enough","text":"<p>Modular projects start strong.</p> <ul> <li>You group code by features.</li> <li>Each folder has its own API, logic, components.</li> <li>Everything feels clean and local.</li> </ul> <p>But over time, you notice:</p> <ul> <li>GPT integration logic is copied across <code>chatbot/</code>, <code>invoice/</code>, and <code>upload/</code></li> <li>Background jobs now need persistent task queues</li> <li>You want a unified logging or auth mechanism across all routes</li> <li>Features need to communicate or share resources</li> <li>Tests break because modules are not as isolated as you thought</li> </ul> <p>You\u2019ve outgrown pure modularity. You\u2019ve reached what we call scale pressure.</p>"},{"location":"chapter11/#signs-youve-hit-scale-pressure","title":"Signs You\u2019ve Hit Scale Pressure","text":"Symptom What It Indicates Shared logic is being duplicated You need a services layer Routing and auth logic are scattered You need centralized core APIs and middleware Features depend on the same DB or vector store You need a consistent infrastructure abstraction CI/CD builds are too slow You need layered test scopes or monorepo tooling Cross-feature coordination is rising You need a global state and message orchestration model New contributors ask: \u201cWhere does this go?\u201d Your structure has stopped scaling mentally <p>Modular gets you started. Scalability is what keeps you shipping as your codebase, team, and traffic grow.</p>"},{"location":"chapter11/#layered-thinking-the-heart-of-scalability","title":"Layered Thinking: The Heart of Scalability","text":"<p>Scalable architecture means thinking in layers, not just folders.</p> <p>You begin separating:</p> <ul> <li>API (routing surface area)</li> <li>Services (business logic, workflows, AI ops)</li> <li>Schemas (data contracts, Pydantic models, API types)</li> <li>Infrastructure (vector DBs, storage clients, external APIs)</li> <li>Core (configuration, middlewares, permissions, logging)</li> </ul> <p>In frontend apps, this translates to:</p> <ul> <li><code>api/</code>, <code>services/</code>, <code>components/</code>, <code>hooks/</code>, <code>context/</code>, <code>ui/</code></li> </ul> <p>In backend apps:</p> <ul> <li><code>api/</code>, <code>services/</code>, <code>schemas/</code>, <code>core/</code>, <code>infra/</code>, <code>tasks/</code></li> </ul> <p>Each layer has its boundaries, interfaces, and contracts.</p> <p>Structure becomes more than organization\u2014it becomes system design.</p>"},{"location":"chapter11/#what-does-scalable-structure-unlock","title":"What Does Scalable Structure Unlock?","text":"Benefit Description \u2705 Replaceability Swap GPT for Claude with one service rewrite \u2705 Parallelism Teams work in isolated layers, avoiding collisions \u2705 Observability Logging, metrics, and tracing are consistent \u2705 CI/CD Optimization Build pipelines by layer, not whole app \u2705 Refactor Safety Features don\u2019t leak logic into global state \u2705 Compliance/Access Control Role-based logic enforced at routing/middleware layer <p>This is critical for:</p> <ul> <li>Multi-team platforms</li> <li>Enterprise apps</li> <li>Complex AI pipelines (RAG, OCR, embeddings, summaries)</li> <li>Any product with sustained iteration over years</li> </ul>"},{"location":"chapter11/#when-should-you-go-scalable","title":"When Should You Go Scalable?","text":"<p>You don\u2019t always need to start scalable. You scale when one of the following becomes true:</p> Trigger Time to Scale Shared logic becomes unmaintainable \u2705 Yes You have 2+ developers working on different modules \u2705 Yes CI/CD takes too long to run on every commit \u2705 Yes You\u2019re deploying background workers or async task queues \u2705 Yes Your app has &gt;5 core features across 2+ verticals \u2705 Yes You\u2019re prototyping something experimental \u274c No (stay modular) You\u2019re a solo dev testing an idea \u274c No (stay lightweight)"},{"location":"chapter11/#modular-scalable-the-mindset-shift","title":"Modular \u2192 Scalable: The Mindset Shift","text":"From (Modular) To (Scalable) Feature = Folder Feature = Composition of layers Duplication is fine Duplication is replaced by shared services Minimal coupling Controlled global orchestration Feature owns its logic Logic moves to dedicated <code>services/</code>, <code>infra/</code> Routes are defined in features Routes are registered and versioned via <code>api/</code> layer Tests are colocated Tests may span modules, layers, or be orchestrated via CI groups <p>This mindset shift doesn\u2019t remove modularity. It wraps it inside a more scalable, maintainable, layered system.</p>"},{"location":"chapter11/#summary","title":"Summary","text":"<p>Scalable architecture is the natural evolution of modular systems:</p> <ul> <li>It preserves feature clarity</li> <li>It enforces layer boundaries</li> <li>It enables growth, testing, and cross-team velocity</li> <li>It makes your system replaceable, not rigid</li> </ul> <p>In the chapters ahead, you\u2019ll learn exactly how to structure React and FastAPI apps for this next level:</p> <ul> <li>From folder naming to service boundaries</li> <li>From UI components to orchestration layers</li> <li>From monofeature MVPs to production-ready platforms</li> </ul>"},{"location":"chapter12/","title":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Chapter 12","text":""},{"location":"chapter12/#part-3-scalability","title":"Part 3: Scalability","text":""},{"location":"chapter12/#12-scalable-folder-structure-for-react-vite","title":"12. Scalable Folder Structure for React + Vite","text":"<p>\u201cWhen your features multiply, your structure must evolve from modules to layers.\u201d</p>"},{"location":"chapter12/#from-modular-to-layered-thinking","title":"From Modular to Layered Thinking","text":"<p>In a modular frontend, each feature folder owns everything it needs:</p> <ul> <li>UI components</li> <li>Hooks</li> <li>API calls</li> <li>Styles</li> </ul> <p>But at scale\u2014especially in apps powered by GPT, vector DBs, and real-time state\u2014you need:</p> <ul> <li>Shared data access across features</li> <li>Global UI consistency</li> <li>Reusable design tokens, hooks, services</li> <li>Better state orchestration</li> </ul> <p>That\u2019s when feature-first breaks down. And layer-first architecture takes over.</p>"},{"location":"chapter12/#recommended-scalable-folder-layout","title":"Recommended Scalable Folder Layout","text":"<p>Here\u2019s a common, proven structure:</p> <pre><code>src/\n\u251c\u2500\u2500 api/                # Centralized backend request clients\n\u251c\u2500\u2500 services/           # Business logic, GPT helpers, session managers\n\u251c\u2500\u2500 components/         # Reusable UI elements (e.g., Button, Modal)\n\u251c\u2500\u2500 hooks/              # Shared, cross-feature hooks\n\u251c\u2500\u2500 pages/              # Route-level views\n\u251c\u2500\u2500 features/           # Optional: feature-specific UI slices\n\u251c\u2500\u2500 context/            # React Context providers for global state\n\u251c\u2500\u2500 store/              # Zustand/Jotai/Recoil state atoms/selectors\n\u251c\u2500\u2500 styles/             # Global styles, Tailwind config, tokens\n\u251c\u2500\u2500 ui/                 # Shared design system\n\u251c\u2500\u2500 utils/              # Generic utility functions\n\u251c\u2500\u2500 constants/          # Enum definitions, global config\n\u2514\u2500\u2500 main.tsx            # App entry point\n</code></pre> <p>This structure scales both with code and with teams.</p>"},{"location":"chapter12/#layer-breakdown","title":"Layer Breakdown","text":"<p>Let\u2019s zoom in on each layer.</p>"},{"location":"chapter12/#api","title":"<code>/api/</code>","text":"<ul> <li>Purpose: Handle all network requests (REST, GraphQL, streaming)</li> <li>Contents: <code>chat.ts</code>, <code>invoice.ts</code>, <code>user.ts</code></li> <li>Pattern: Export clean functions \u2192 <code>getMessages()</code>, <code>postInvoice()</code></li> <li>Optional: Create axios/fetch client with interceptors</li> </ul> <p>Benefits:</p> <ul> <li>All APIs are discoverable in one place</li> <li>Easily mockable for testing</li> <li>No direct fetch logic inside components</li> </ul>"},{"location":"chapter12/#services","title":"<code>/services/</code>","text":"<ul> <li>Purpose: App-level logic (e.g., GPT workflows, token management, document preprocessing)</li> <li>Contents: <code>gptService.ts</code>, <code>authService.ts</code>, <code>uploadManager.ts</code></li> <li>May call <code>api/</code> internally</li> </ul> <p>Use services to:</p> <ul> <li>Encapsulate async logic</li> <li>Coordinate multi-step flows</li> <li>Reduce logic bloat in components/hooks</li> </ul>"},{"location":"chapter12/#components-and-ui","title":"<code>/components/</code> and <code>/ui/</code>","text":"<ul> <li>Purpose: Core UI primitives + custom reusable components</li> <li> <p>Contents:</p> </li> <li> <p><code>components/</code>: App-specific components (<code>ChatBox</code>, <code>InvoiceForm</code>)</p> </li> <li><code>ui/</code>: Design system components (<code>Button</code>, <code>Tooltip</code>, <code>Card</code>)</li> </ul> <p>Tip: Start with <code>components/</code>. Create <code>ui/</code> when things repeat.</p>"},{"location":"chapter12/#hooks","title":"<code>/hooks/</code>","text":"<ul> <li>Purpose: Global reusable hooks</li> <li> <p>Examples:</p> </li> <li> <p><code>useCopyToClipboard.ts</code></p> </li> <li><code>useLocalStorage.ts</code></li> <li><code>useWindowFocus.ts</code></li> </ul> <p>Each hook should:</p> <ul> <li>Be scoped and named clearly</li> <li>Avoid feature-specific logic</li> <li>Be mockable in tests</li> </ul>"},{"location":"chapter12/#context-and-store","title":"<code>/context/</code> and <code>/store/</code>","text":"<ul> <li>Purpose: Global or scoped state management</li> <li><code>/context/</code>: React Contexts</li> <li><code>/store/</code>: Zustand or Jotai atoms/selectors</li> </ul> <p>Scalable apps use context only where it makes sense:</p> <ul> <li>Auth session</li> <li>Theme</li> <li>UI notifications</li> </ul> <p>Use store for:</p> <ul> <li>Shared state across features</li> <li>Subscribable, testable state atoms</li> </ul>"},{"location":"chapter12/#pages","title":"<code>/pages/</code>","text":"<ul> <li>Purpose: Route entry points</li> <li> <p>Pattern:</p> </li> <li> <p><code>pages/index.tsx</code> \u2192 Home</p> </li> <li><code>pages/chat.tsx</code> \u2192 Chat interface</li> <li><code>pages/invoice.tsx</code> \u2192 Upload + GPT result view</li> </ul> <p>These load views and pass props \u2192 logic and UI come from other layers.</p>"},{"location":"chapter12/#features-optional-at-scale","title":"<code>/features/</code> (Optional at scale)","text":"<p>If you want to preserve modularity at a high level, you can still group:</p> <pre><code>features/\n\u251c\u2500\u2500 chatbot/\n\u2502   \u251c\u2500\u2500 ChatPage.tsx\n\u2502   \u251c\u2500\u2500 hooks/\n\u2502   \u251c\u2500\u2500 services/\n</code></pre> <p>This is useful if your team is organized by feature verticals. Otherwise, it may blur with the layer-first model\u2014choose one primary style.</p>"},{"location":"chapter12/#managing-cross-feature-state-and-logic","title":"Managing Cross-Feature State and Logic","text":"<p>At scale, you need shared flows:</p> <ul> <li>Multiple features might rely on GPT logic</li> <li>Upload state might be accessed in both <code>invoice/</code> and <code>chat/</code></li> <li>Auth roles need to affect route visibility and UI</li> </ul> <p>Strategies:</p> <ul> <li>Keep shared logic in <code>services/</code>, not in components</li> <li>Keep global state in <code>store/</code>, scoped state in <code>hooks/</code></li> <li>Avoid relying on <code>window</code> or ad-hoc <code>localStorage</code> access</li> </ul> <p>Structure enables state control and predictable data flow.</p>"},{"location":"chapter12/#shared-ui-systems-and-design-tokens","title":"Shared UI Systems and Design Tokens","text":"<p>Create a design system via:</p> <pre><code>styles/\n\u251c\u2500\u2500 tailwind.config.js\n\u251c\u2500\u2500 tokens/\n\u2502   \u251c\u2500\u2500 colors.ts\n\u2502   \u251c\u2500\u2500 spacing.ts\n\u2502   \u2514\u2500\u2500 typography.ts\n</code></pre> <p>And combine it with:</p> <pre><code>ui/\n\u251c\u2500\u2500 Button.tsx\n\u251c\u2500\u2500 Input.tsx\n\u251c\u2500\u2500 Card.tsx\n</code></pre> <p>Benefits:</p> <ul> <li>Consistent styling across the app</li> <li>Easily themeable</li> <li>Component libraries become pluggable</li> </ul>"},{"location":"chapter12/#supporting-multiple-teams-on-the-same-codebase","title":"Supporting Multiple Teams on the Same Codebase","text":"<p>If your project has &gt;2 frontend contributors:</p> <ul> <li>Split teams by domain (e.g., Chat, Upload, Dashboard)</li> <li>Define clear ownership of <code>/features/</code>, <code>/services/</code>, and <code>/components/</code></li> <li>Use codeowners, PR checklists, or monorepo tooling (Nx, Turborepo) to divide boundaries</li> <li>Consider creating visual regression snapshots or storybook previews</li> </ul> <p>Structure gives teams room to scale without stepping on each other.</p>"},{"location":"chapter12/#summary-scalable-react-structure-principles","title":"Summary: Scalable React Structure Principles","text":"Layer Purpose <code>api/</code> Encapsulate backend interaction <code>services/</code> Handle app-level logic and AI workflows <code>hooks/</code> Share non-UI logic across components <code>components/</code>, <code>ui/</code> Reusable UI building blocks <code>pages/</code> Entry point views for routes <code>context/</code>, <code>store/</code> Global state providers and management <code>styles/</code>, <code>tokens/</code> Design system configuration and theming <p>Scaling React isn't about folders. It\u2019s about building structure that reflects flow, ownership, and reuse.</p>"},{"location":"chapter13/","title":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Chapter 13","text":""},{"location":"chapter13/#part-3-scalability","title":"Part 3: Scalability","text":""},{"location":"chapter13/#13-scalable-folder-structure-for-fastapi","title":"13. Scalable Folder Structure for FastAPI","text":"<p>\u201cWhen APIs grow, folder structure becomes your defense against entropy.\u201d</p>"},{"location":"chapter13/#why-scalability-hits-the-backend-first","title":"Why Scalability Hits the Backend First","text":"<p>React can get away with a little mess. FastAPI cannot.</p> <p>As your backend evolves to support:</p> <ul> <li>Auth and permission layers</li> <li>Vector DBs, async GPT pipelines, OCR parsing</li> <li>Multiple API versions</li> <li>Streaming, WebSockets, background jobs</li> </ul> <p>\u2026your old <code>api/</code>, <code>services/</code>, <code>schemas/</code> layout starts to strain.</p> <p>You need a layered backend architecture that:</p> <ul> <li>Supports independent deployments</li> <li>Reduces coupling between services</li> <li>Enables async, task-driven workflows</li> <li>Maintains testability and refactor-safety</li> </ul>"},{"location":"chapter13/#recommended-scalable-fastapi-folder-layout","title":"Recommended Scalable FastAPI Folder Layout","text":"<pre><code>app/\n\u251c\u2500\u2500 api/                # Route definitions (per version, grouped by domain)\n\u2502   \u251c\u2500\u2500 v1/\n\u2502   \u2502   \u251c\u2500\u2500 chatbot.py\n\u2502   \u2502   \u251c\u2500\u2500 invoice.py\n\u2502   \u2502   \u2514\u2500\u2500 upload.py\n\u251c\u2500\u2500 services/           # Business logic (GPT, processing, workflows)\n\u2502   \u251c\u2500\u2500 gpt_service.py\n\u2502   \u251c\u2500\u2500 invoice_parser.py\n\u2502   \u2514\u2500\u2500 embedding_service.py\n\u251c\u2500\u2500 schemas/            # Pydantic models for API input/output\n\u2502   \u251c\u2500\u2500 chatbot.py\n\u2502   \u251c\u2500\u2500 invoice.py\n\u2502   \u2514\u2500\u2500 shared.py\n\u251c\u2500\u2500 core/               # App settings, middleware, auth guards\n\u2502   \u251c\u2500\u2500 config.py\n\u2502   \u251c\u2500\u2500 security.py\n\u2502   \u2514\u2500\u2500 exceptions.py\n\u251c\u2500\u2500 infra/              # External systems (DB, VectorDB, S3, Celery)\n\u2502   \u251c\u2500\u2500 database.py\n\u2502   \u251c\u2500\u2500 supabase.py\n\u2502   \u251c\u2500\u2500 weaviate.py\n\u2502   \u2514\u2500\u2500 celery_worker.py\n\u251c\u2500\u2500 tasks/              # Background task definitions\n\u2502   \u2514\u2500\u2500 process_invoice.py\n\u251c\u2500\u2500 shared/             # Utilities used across layers\n\u2502   \u251c\u2500\u2500 ocr.py\n\u2502   \u251c\u2500\u2500 image_utils.py\n\u2502   \u2514\u2500\u2500 logging.py\n\u251c\u2500\u2500 main.py             # FastAPI app entry point\n\u2514\u2500\u2500 routers.py          # Route inclusion logic\n</code></pre> <p>This structure mirrors clean architecture and DDD layering, while staying idiomatic to FastAPI.</p>"},{"location":"chapter13/#key-layers-and-responsibilities","title":"Key Layers and Responsibilities","text":"Layer Purpose <code>api/</code> Route definitions, versioning, and decorators <code>services/</code> Business logic, orchestration, pipeline steps <code>schemas/</code> Data contracts between client and backend <code>core/</code> Security, config, middleware, exception handling <code>infra/</code> External resources like DBs, VectorStores, file storage <code>tasks/</code> Async background jobs (Celery, BackgroundTasks) <code>shared/</code> Utility functions reused across modules <code>tests/</code> May live locally or in root folder, depending on scale"},{"location":"chapter13/#clean-separation-of-router-service-and-schema","title":"Clean Separation of Router, Service, and Schema","text":"<p>FastAPI makes it easy to blur lines\u2014resist the temptation.</p> <p>Bad Pattern:</p> <pre><code>@app.post(\"/chat\")\ndef chat_handler(input: str = Body(...)):\n    response = openai.ChatCompletion.create(...)\n    return response\n</code></pre> <p>Scalable Pattern:</p> <pre><code># api/v1/chatbot.py\n@router.post(\"/chat\", response_model=ChatResponse)\ndef handle_chat(input: ChatInput, svc: GPTService = Depends()):\n    return svc.generate_response(input)\n\n# services/gpt_service.py\nclass GPTService:\n    def generate_response(self, input: ChatInput) -&gt; ChatResponse:\n        ...\n</code></pre> <p>Why?</p> <ul> <li>Routes should be thin</li> <li>Services should be testable</li> <li>Schemas should be reusable</li> </ul>"},{"location":"chapter13/#versioned-routing-and-scalable-endpoints","title":"Versioned Routing and Scalable Endpoints","text":"<p>Structure your <code>api/</code> like this:</p> <pre><code>api/\n\u251c\u2500\u2500 v1/\n\u2502   \u251c\u2500\u2500 chatbot.py\n\u2502   \u251c\u2500\u2500 invoice.py\n\u2502   \u2514\u2500\u2500 upload.py\n\u251c\u2500\u2500 v2/\n\u2502   \u2514\u2500\u2500 chatbot.py\n</code></pre> <p>In <code>main.py</code> or <code>routers.py</code>:</p> <pre><code>app.include_router(v1.chatbot.router, prefix=\"/v1/chatbot\")\napp.include_router(v2.chatbot.router, prefix=\"/v2/chatbot\")\n</code></pre> <p>Benefits:</p> <ul> <li>Non-breaking upgrades</li> <li>Parallel development of new features</li> <li>Easier deprecation and API sunset cycles</li> </ul>"},{"location":"chapter13/#supporting-background-jobs","title":"Supporting Background Jobs","text":"<p>Background processing becomes essential at scale:</p> <ul> <li>GPT calls that exceed request timeouts</li> <li>OCR-heavy image parsing</li> <li>Long-running embedding workflows</li> </ul> <p>Structure:</p> <pre><code>tasks/\n\u251c\u2500\u2500 embed_document.py\n\u251c\u2500\u2500 process_invoice.py\n\u2514\u2500\u2500 reindex_vector_db.py\n</code></pre> <p>Use:</p> <ul> <li><code>BackgroundTasks</code> (FastAPI native, simple cases)</li> <li><code>Celery</code> + Redis (robust task queue)</li> <li><code>RQ</code>, <code>dramatiq</code>, or <code>Huey</code> (lightweight alternatives)</li> </ul> <p>Keep <code>tasks/</code> decoupled from <code>api/</code>\u2014triggered by <code>services/</code>.</p>"},{"location":"chapter13/#auth-permissions-and-role-based-modules","title":"Auth, Permissions, and Role-Based Modules","text":"<p>Place guards and JWT logic in:</p> <pre><code>core/\n\u251c\u2500\u2500 security.py       # Auth check functions, token decode/validate\n\u251c\u2500\u2500 permissions.py    # Role-based access checks\n\u2514\u2500\u2500 dependencies.py   # Dependency injection helpers\n</code></pre> <p>In route:</p> <pre><code>@router.post(\"/secure-action\", dependencies=[Depends(require_admin)])\ndef admin_only_action():\n    ...\n</code></pre> <ul> <li>Clean</li> <li>Declarative</li> <li>Testable</li> </ul>"},{"location":"chapter13/#repository-pattern-for-data-access","title":"Repository Pattern for Data Access","text":"<p>To decouple DB from services:</p> <pre><code>infra/\n\u251c\u2500\u2500 database.py           # Engine + session\n\u251c\u2500\u2500 repositories/\n\u2502   \u251c\u2500\u2500 user_repo.py\n\u2502   \u2514\u2500\u2500 invoice_repo.py\n</code></pre> <p>Services call repositories, not <code>Session</code> or raw SQL:</p> <pre><code>class InvoiceService:\n    def __init__(self, repo: InvoiceRepository):\n        self.repo = repo\n\n    def create_invoice(...):\n        return self.repo.insert_invoice(...)\n</code></pre> <p>This enables:</p> <ul> <li>Swappable DBs (e.g., PostgreSQL \u2192 Supabase)</li> <li>Easier mocking in tests</li> <li>Separation of query logic from business flow</li> </ul>"},{"location":"chapter13/#summary-fastapi-at-scale","title":"Summary: FastAPI at Scale","text":"Concern Where It Lives Routes <code>api/v1/</code> Business logic <code>services/</code> Schema validation <code>schemas/</code> Config/auth/middleware <code>core/</code> VectorDB, Celery, S3 <code>infra/</code> Async tasks <code>tasks/</code> Shared utils <code>shared/</code> API versioning <code>api/v1/</code>, <code>api/v2/</code> Role-based access <code>core/security.py</code>, <code>permissions.py</code> <p>This structure prepares your backend to:</p> <ul> <li>Handle growing teams and responsibilities</li> <li>Expand into multi-feature orchestration</li> <li>Scale horizontally (via services) and vertically (via workers/tasks)</li> </ul> <p>In the next chapter, we\u2019ll zoom out to deployment concerns\u2014and how structure directly impacts your CI/CD, Dockerization, and scaling workflows.</p>"},{"location":"chapter14/","title":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Chapter 14","text":""},{"location":"chapter14/#part-3-scalability","title":"Part 3: Scalability","text":""},{"location":"chapter14/#14-deploying-and-scaling-react-fastapi-projects","title":"14. Deploying and Scaling React + FastAPI Projects","text":"<p>\u201cYour folder structure isn't just for developers\u2014it's for deployment, too.\u201d</p>"},{"location":"chapter14/#why-structure-impacts-deployment","title":"Why Structure Impacts Deployment","text":"<p>It\u2019s easy to treat folder structure as a dev-only concern.</p> <p>But the moment you deploy, you realize:</p> <ul> <li>CI/CD needs clean build scopes</li> <li>Docker needs clear entry points and build contexts</li> <li>Secrets must be isolated per environment</li> <li>Public assets and static files must follow web server rules</li> <li>Infrastructure-as-Code (IaC) prefers predictable file paths</li> </ul> <p>A scalable folder structure ensures:</p> <ul> <li>Reliable deploys</li> <li>Fast builds</li> <li>Safe environments</li> <li>Consistent developer \u2192 staging \u2192 production flows</li> </ul>"},{"location":"chapter14/#recommended-project-root-layout-monorepo-style","title":"Recommended Project Root Layout (Monorepo Style)","text":"<pre><code>project-root/\n\u251c\u2500\u2500 frontend/              # React + Vite app\n\u2502   \u251c\u2500\u2500 src/\n\u2502   \u251c\u2500\u2500 public/\n\u2502   \u251c\u2500\u2500 index.html\n\u2502   \u2514\u2500\u2500 vite.config.ts\n\u251c\u2500\u2500 backend/               # FastAPI app\n\u2502   \u251c\u2500\u2500 app/\n\u2502   \u251c\u2500\u2500 requirements.txt\n\u2502   \u251c\u2500\u2500 main.py\n\u2502   \u2514\u2500\u2500 Dockerfile\n\u251c\u2500\u2500 .github/               # GitHub Actions workflows\n\u2502   \u2514\u2500\u2500 workflows/\n\u251c\u2500\u2500 docker/\n\u2502   \u251c\u2500\u2500 nginx/             # Optional reverse proxy\n\u2502   \u251c\u2500\u2500 docker-compose.yml\n\u251c\u2500\u2500 .env                   # Default environment config\n\u251c\u2500\u2500 README.md\n\u2514\u2500\u2500 Caddyfile / nginx.conf # Optional web server configs\n</code></pre> <p>This structure:</p> <ul> <li>Separates build boundaries</li> <li>Allows independent or joint deployment</li> <li>Works well for Docker, Heroku, Render, Railway, GCP, AWS</li> </ul>"},{"location":"chapter14/#docker-best-practices-for-scalable-structure","title":"Docker Best Practices for Scalable Structure","text":"<p>Frontend <code>Dockerfile</code> (React + Vite):</p> <pre><code>FROM node:18 AS build\nWORKDIR /app\nCOPY frontend/ ./\nRUN npm install &amp;&amp; npm run build\n\nFROM nginx:alpine\nCOPY --from=build /app/dist /usr/share/nginx/html\nCOPY docker/nginx/nginx.conf /etc/nginx/conf.d/default.conf\n</code></pre> <p>Backend <code>Dockerfile</code> (FastAPI):</p> <pre><code>FROM python:3.11\nWORKDIR /app\nCOPY backend/ .\nRUN pip install -r requirements.txt\nCMD [\"uvicorn\", \"main:app\", \"--host\", \"0.0.0.0\", \"--port\", \"8000\"]\n</code></pre> <p>Benefits of folder-aware Docker:</p> <ul> <li>Minimal build context</li> <li>Clear separation of concerns</li> <li>Fast rebuilds (cache efficient)</li> <li>Works with mono or multi-container setups</li> </ul>"},{"location":"chapter14/#managing-environment-variables-and-secrets","title":"Managing Environment Variables and Secrets","text":"<p>A scalable structure needs isolated environment configs:</p> <pre><code>project-root/\n\u251c\u2500\u2500 .env\n\u251c\u2500\u2500 frontend/.env.development\n\u251c\u2500\u2500 frontend/.env.production\n\u251c\u2500\u2500 backend/.env\n</code></pre> <p>Use tools like:</p> <ul> <li><code>dotenv</code> or Vite's <code>import.meta.env</code> for React</li> <li><code>python-dotenv</code> or <code>os.environ.get()</code> for FastAPI</li> </ul> <p>NEVER COMMIT <code>.env</code> FILES TO GIT Instead, use:</p> <ul> <li><code>.env.example</code></li> <li>Secret managers (e.g., GitHub Actions Secrets, Railway, GCP Secret Manager)</li> </ul>"},{"location":"chapter14/#static-files-and-public-assets","title":"Static Files and Public Assets","text":"<p>Frontend:</p> <ul> <li>Store public files in <code>frontend/public/</code></li> <li>Vite will copy them to <code>dist/</code> at build time</li> </ul> <p>Backend:</p> <ul> <li>Mount static files using FastAPI:</li> </ul> <pre><code>from fastapi.staticfiles import StaticFiles\n\napp.mount(\"/static\", StaticFiles(directory=\"static\"), name=\"static\")\n</code></pre> <ul> <li>Serve docs, previews, or OCR outputs this way</li> </ul> <p>If using Nginx or Caddy, route <code>/static/</code> or <code>/docs/</code> to these folders via reverse proxy.</p>"},{"location":"chapter14/#cicd-and-folder-structure","title":"CI/CD and Folder Structure","text":"<p>A good structure makes CI/CD:</p> <ul> <li>Easier to configure</li> <li>Faster to run</li> <li>Safer to deploy</li> </ul> <p>Example: GitHub Actions Workflow</p> <pre><code>name: Deploy App\n\non:\n  push:\n    branches: [main]\n\njobs:\n  build-frontend:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      - name: Install &amp; Build Frontend\n        working-directory: frontend\n        run: |\n          npm install\n          npm run build\n\n  build-backend:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      - name: Install &amp; Test Backend\n        working-directory: backend\n        run: |\n          pip install -r requirements.txt\n          pytest\n</code></pre> <p>Tips:</p> <ul> <li>Run tests only on changed folders (CI optimization)</li> <li>Use paths like <code>frontend/**</code> or <code>backend/**</code> for job triggers</li> <li>Structure build outputs (<code>dist/</code>, <code>coverage/</code>, <code>artifacts/</code>) cleanly</li> </ul>"},{"location":"chapter14/#scaling-deployment-mono-vs-multi-container","title":"Scaling Deployment: Mono vs Multi-Container","text":"Strategy When to Use Notes Mono-container Simple apps, early stage One container runs both frontend + backend Multi-container Recommended at scale Separate concerns (React container, API container, Nginx, vector DB, etc.) Docker Compose Local dev orchestration Define networks, volumes, and environment links Kubernetes / ECS Advanced scale Define deployment rules, autoscaling, health checks <p>Folder structure should support:</p> <ul> <li>Multiple <code>Dockerfile</code>s</li> <li>Shared <code>.env</code> format</li> <li>Central <code>docker-compose.yml</code></li> </ul>"},{"location":"chapter14/#infrastructure-as-code-iac-and-scaling","title":"Infrastructure as Code (IaC) and Scaling","text":"<p>Once you grow beyond Docker Compose, consider:</p> <ul> <li>Terraform: Define AWS/GCP infrastructure as code</li> <li>Pulumi or Ansible: Automate provisioning</li> <li>GitOps: Auto-deploy based on Git state (ArgoCD, Flux)</li> </ul> <p>Folder tips:</p> <pre><code>infra/\n\u251c\u2500\u2500 terraform/\n\u251c\u2500\u2500 ansible/\n\u2514\u2500\u2500 k8s/\n</code></pre> <p>Structure enables:</p> <ul> <li>Environments (dev, staging, prod)</li> <li>Secure secrets and access</li> <li>CI/CD automation with IaC</li> </ul>"},{"location":"chapter14/#summary-structure-for-deployment-and-scaling","title":"Summary: Structure for Deployment and Scaling","text":"Concern Structure Tip CI/CD pipelines Use separate <code>frontend/</code>, <code>backend/</code> folders with scoped runners Docker build scope Keep <code>Dockerfile</code> close to code, use <code>.dockerignore</code> Secrets management Use <code>.env</code> per app, don\u2019t commit secrets Public assets Use <code>/public/</code> and <code>/static/</code> with correct mounts Multi-service orchestration Use <code>docker/</code>, <code>infra/</code>, and clear service boundaries IaC integration Add <code>infra/</code> or <code>k8s/</code> folders for DevOps teams <p>Your folder structure is the foundation for stable, scalable, reproducible deployments.</p>"},{"location":"chapter15/","title":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Chapter 15","text":""},{"location":"chapter15/#part-4-hybrid-and-advanced-techniques","title":"Part 4: Hybrid and Advanced Techniques","text":""},{"location":"chapter15/#15-hybrid-folder-structures","title":"15. Hybrid Folder Structures","text":"<p>\u201cYou don\u2019t have to choose between modular and scalable. You can evolve through them.\u201d</p>"},{"location":"chapter15/#what-is-a-hybrid-folder-structure","title":"What is a Hybrid Folder Structure?","text":"<p>A hybrid architecture blends feature-first modularity with layered scalability.</p> <p>You keep the independence of modules (e.g., <code>chatbot/</code>, <code>invoice/</code>) But you extract global logic (e.g., GPT, OCR, auth, logging) into reusable layers like <code>services/</code>, <code>core/</code>, and <code>shared/</code>.</p> <p>It\u2019s not either-or. It\u2019s both\u2014with boundaries.</p> <p>Hybrid structure is often a transition state, but it\u2019s also a long-term strategy for many growing apps.</p>"},{"location":"chapter15/#when-should-you-go-hybrid","title":"When Should You Go Hybrid?","text":"<p>You\u2019ve outgrown pure modularity but aren\u2019t ready to go full scalable.</p> <p>Use hybrid when:</p> <ul> <li>You want to preserve feature ownership</li> <li>You need to centralize GPT, OCR, or vector DB logic</li> <li>Your React app has reusable UI systems + scoped features</li> <li>Your FastAPI backend has shared schemas, background tasks, or infra</li> </ul> <p>In short: you're building an AI-first product that must scale over time\u2014without losing its feature velocity.</p>"},{"location":"chapter15/#react-hybrid-folder-example","title":"React: Hybrid Folder Example","text":"<pre><code>src/\n\u251c\u2500\u2500 features/\n\u2502   \u251c\u2500\u2500 chatbot/\n\u2502   \u2502   \u251c\u2500\u2500 ChatPage.tsx\n\u2502   \u2502   \u251c\u2500\u2500 hooks/\n\u2502   \u2502   \u251c\u2500\u2500 api/\n\u2502   \u2502   \u2514\u2500\u2500 __tests__/\n\u2502   \u2514\u2500\u2500 invoice/\n\u2502       \u251c\u2500\u2500 UploadPage.tsx\n\u2502       \u251c\u2500\u2500 components/\n\u2502       \u2514\u2500\u2500 __tests__/\n\u251c\u2500\u2500 api/              # Global API clients\n\u251c\u2500\u2500 services/         # Shared GPT, auth, upload logic\n\u251c\u2500\u2500 components/       # Shared UI components\n\u251c\u2500\u2500 hooks/            # Global utilities\n\u251c\u2500\u2500 context/          # Auth, theme, toast providers\n\u2514\u2500\u2500 store/            # Global state\n</code></pre> <p>You preserve feature folders for UI flow, but global workflows are abstracted to <code>/services/</code>.</p> <p>Example:</p> <ul> <li><code>useChatSession()</code> \u2192 uses <code>gptService.generateResponse()</code></li> <li><code>uploadInvoice()</code> \u2192 uses <code>uploadService.sendFile()</code></li> </ul>"},{"location":"chapter15/#fastapi-hybrid-folder-example","title":"FastAPI: Hybrid Folder Example","text":"<pre><code>app/\n\u251c\u2500\u2500 chatbot/\n\u2502   \u251c\u2500\u2500 api/\n\u2502   \u251c\u2500\u2500 schemas/\n\u2502   \u251c\u2500\u2500 __tests__/\n\u251c\u2500\u2500 invoice/\n\u2502   \u251c\u2500\u2500 api/\n\u2502   \u2514\u2500\u2500 __tests__/\n\u251c\u2500\u2500 api/              # Versioned routing entry points\n\u251c\u2500\u2500 services/         # GPT, embeddings, invoice parsing\n\u251c\u2500\u2500 schemas/          # Shared schemas (e.g., pagination, base models)\n\u251c\u2500\u2500 infra/            # DB, vector store, Celery, Redis\n\u251c\u2500\u2500 tasks/            # Background jobs\n\u251c\u2500\u2500 core/             # Config, security, middlewares\n\u2514\u2500\u2500 main.py\n</code></pre> <p>Each feature still has local routes, but GPT logic is unified under <code>services/gpt_service.py</code>.</p> <p>This allows:</p> <ul> <li>Parallel feature work</li> <li>Centralized optimization of shared layers</li> <li>Modular tests + scalable deployment</li> </ul>"},{"location":"chapter15/#evolving-from-modular-hybrid-scalable","title":"Evolving from Modular \u2192 Hybrid \u2192 Scalable","text":"<p>Here\u2019s a safe evolution path:</p> Stage Folder Traits 1. Modular Feature-first: <code>chatbot/</code>, <code>invoice/</code>, <code>upload/</code> 2. Hybrid Extract shared logic into <code>/services/</code>, <code>/shared/</code>, <code>/infra/</code> 3. Scalable Add strict layering: <code>/api</code>, <code>/core</code>, versioned APIs, DI, repository pattern, CI testing scopes <p>Use refactor points as checkpoints:</p> <ul> <li>GPT logic duplicated? Extract to <code>services/</code></li> <li>OCR utils copy-pasted? Move to <code>shared/ocr.py</code></li> <li>Tests cross module boundaries? Split into <code>integration/</code> vs <code>unit/</code></li> <li>CI/CD too slow? Use per-layer workflows</li> </ul>"},{"location":"chapter15/#hybrid-folder-design-goals","title":"Hybrid Folder Design Goals","text":"Goal Design Strategy Preserve modular feature flow Keep <code>features/</code> or scoped <code>chatbot/</code> folders Enable shared logic reuse Extract to <code>services/</code>, <code>shared/</code>, <code>infra/</code> Avoid tight coupling Use dependency injection or shared interfaces Keep tests isolated Per-feature <code>__tests__/</code>, global mocks in <code>test_helpers/</code> Support CI pipelines Build/test/deploy by folder scope (e.g., backend only if changed)"},{"location":"chapter15/#migration-patterns-how-to-transition-gracefully","title":"Migration Patterns: How to Transition Gracefully","text":""},{"location":"chapter15/#pattern-move-first-test-later","title":"Pattern: \u201cMove First, Test Later\u201d","text":"<ul> <li>Duplicate shared logic into <code>services/</code></li> <li>Use feature logic first</li> <li>Then write unit tests for <code>services/</code></li> </ul>"},{"location":"chapter15/#pattern-wrapper-injection","title":"Pattern: \u201cWrapper Injection\u201d","text":"<ul> <li>Refactor GPT calls in <code>chatbot/</code> into a <code>GPTService</code> class</li> <li>Inject into multiple modules via shared <code>services/</code></li> </ul>"},{"location":"chapter15/#pattern-refactor-by-volume","title":"Pattern: \u201cRefactor by Volume\u201d","text":"<ul> <li>Identify most-used utilities</li> <li>Extract only those</li> <li>Avoid premature generalization</li> </ul>"},{"location":"chapter15/#pattern-use-mocks-to-abstract-away","title":"Pattern: \u201cUse Mocks to Abstract Away\u201d","text":"<ul> <li>Test <code>chatbot/</code> using fake <code>GPTService</code> before moving the real one</li> </ul> <p>These patterns let you gradually scale without breaking working modules.</p>"},{"location":"chapter15/#summary-hybrid-folder-structures","title":"Summary: Hybrid Folder Structures","text":"Principle Application Modularity gives ownership Keep <code>features/</code> or <code>modules/</code> for UI/business domains Scalability gives reuse Extract to <code>/services/</code>, <code>/shared/</code>, <code>/infra/</code> Don\u2019t generalize too early Refactor real patterns only Use folder structure as a signal Is logic reused? Move it. Is it tightly scoped? Keep it local Test per module, share mocks globally <code>test_helpers/</code> supports the hybrid layer boundary <p>Hybrid isn\u2019t a compromise. It\u2019s a mature middle state\u2014ready to support real AI workflows, rapid iteration, and future scale.</p>"},{"location":"chapter16/","title":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Chapter 16","text":""},{"location":"chapter16/#part-4-hybrid-and-advanced-techniques","title":"Part 4: Hybrid and Advanced Techniques","text":""},{"location":"chapter16/#16-monorepos-and-shared-logic","title":"16. Monorepos and Shared Logic","text":"<p>\u201cWhen frontend and backend speak the same language, everything moves faster.\u201d</p>"},{"location":"chapter16/#why-consider-a-monorepo","title":"Why Consider a Monorepo?","text":"<p>As your project grows to include:</p> <ul> <li>A React + Vite frontend</li> <li>A FastAPI backend</li> <li>Shared validation schemas</li> <li>Auth/session logic reused across layers</li> <li>Common constants or types (e.g., document status, GPT response formats)</li> </ul> <p>\u2026it becomes inefficient to split them across multiple repos.</p> <p>A monorepo solves this by keeping everything in one place:</p> <ul> <li>Easier dev experience</li> <li>Shared logic is centralized</li> <li>Faster refactoring</li> <li>Smoother version control</li> <li>Unified CI/CD</li> </ul> <p>You stop duplicating logic\u2014and start aligning systems.</p>"},{"location":"chapter16/#example-monorepo-folder-layout","title":"Example Monorepo Folder Layout","text":"<pre><code>project-root/\n\u251c\u2500\u2500 apps/\n\u2502   \u251c\u2500\u2500 frontend/             # React + Vite app\n\u2502   \u2514\u2500\u2500 backend/              # FastAPI app\n\u251c\u2500\u2500 packages/\n\u2502   \u251c\u2500\u2500 shared-schemas/       # Pydantic + TypeScript shared types\n\u2502   \u251c\u2500\u2500 utils/                # Shared logic, constants, helpers\n\u2502   \u2514\u2500\u2500 gpt-core/             # Shared GPT prompt logic and formatting\n\u251c\u2500\u2500 .github/\n\u2502   \u2514\u2500\u2500 workflows/\n\u251c\u2500\u2500 docker/\n\u2502   \u251c\u2500\u2500 docker-compose.yml\n\u251c\u2500\u2500 tsconfig.base.json\n\u251c\u2500\u2500 pyproject.toml / requirements.txt\n\u251c\u2500\u2500 README.md\n\u2514\u2500\u2500 turbo.json / nx.json / package.json\n</code></pre>"},{"location":"chapter16/#shared-logic-that-actually-matters","title":"Shared Logic That Actually Matters","text":"Shared Concern Example Schemas Upload payloads, response DTOs, user objects Types/Enums DocumentStatus, ModelSource, RoleType Prompt templates GPT input formats shared across frontend + backend Utils Token counters, validators, text normalization Constants Max tokens, file size limits, system settings <p>Keeping these in <code>packages/</code> avoids:</p> <ul> <li>Duplication</li> <li>Divergent validation logic</li> <li>Fragile JSON conversions</li> </ul>"},{"location":"chapter16/#setting-up-shared-packages","title":"Setting Up Shared Packages","text":"<p>Let\u2019s say you use:</p> <ul> <li>TypeScript in frontend</li> <li>Python in backend</li> <li>Shared schemas in both</li> </ul>"},{"location":"chapter16/#for-typescript","title":"For TypeScript:","text":"<p>Use pnpm workspaces or Turborepo to manage shared packages.</p> <p><code>package.json</code> (root):</p> <pre><code>{\n  \"private\": true,\n  \"workspaces\": [\n    \"apps/*\",\n    \"packages/*\"\n  ]\n}\n</code></pre> <p>Example: <code>packages/shared-schemas/src/index.ts</code></p> <pre><code>export interface ChatRequest {\n  message: string\n  model?: \"gpt-3.5\" | \"gpt-4\"\n}\n</code></pre> <p>Then in frontend:</p> <pre><code>import { ChatRequest } from \"@shared-schemas\"\n</code></pre>"},{"location":"chapter16/#for-python-backend","title":"For Python (Backend):","text":"<p>Use <code>poetry</code>, <code>pip install -e .</code>, or a dedicated <code>shared/</code> module.</p> <p>Example: <code>packages/shared_schemas/chat.py</code></p> <pre><code>from pydantic import BaseModel\n\nclass ChatRequest(BaseModel):\n    message: str\n    model: str = \"gpt-3.5\"\n</code></pre> <p>Then in <code>backend/app/api/chat.py</code>:</p> <pre><code>from shared_schemas.chat import ChatRequest\n</code></pre> <p>\ud83d\udca1 Want even tighter sync? Use datamodel-code-generator to generate Pydantic models from TypeScript types, or vice versa.</p>"},{"location":"chapter16/#tools-for-managing-monorepos","title":"Tools for Managing Monorepos","text":"Tool Use Case Turborepo JS monorepo with React + shared packages pnpm Fast dependency management and workspace linking Nx Task orchestration and code boundaries across apps Poetry Python package management for shared backends Docker Compose Dev containers for both frontend + backend GitHub Actions Per-folder CI pipelines and test triggers <p>Use monorepo-aware tooling to:</p> <ul> <li>Avoid rebuilding everything on every commit</li> <li>Run only affected tests or builds</li> <li>Deploy changed services selectively</li> </ul>"},{"location":"chapter16/#testing-shared-logic","title":"Testing Shared Logic","text":"<p>Create shared test folders inside packages:</p> <pre><code>packages/\n\u251c\u2500\u2500 shared-schemas/\n\u2502   \u2514\u2500\u2500 __tests__/\n\u251c\u2500\u2500 gpt-core/\n\u2502   \u2514\u2500\u2500 test_templates.py\n</code></pre> <p>Run tests locally or in CI by glob pattern:</p> <ul> <li><code>pytest packages/gpt-core/</code></li> <li><code>vitest run packages/shared-schemas/</code></li> </ul> <p>This ensures shared logic stays robust without depending on app-specific tests.</p>"},{"location":"chapter16/#versioning-shared-logic","title":"Versioning Shared Logic","text":"<p>You have two choices:</p> <ol> <li>Tightly coupled: Always deploy shared changes with apps (e.g., GPT prompt template update used by both frontend and backend)  </li> <li>Loosely versioned: Use semver tags, changelogs, and publishing flow (e.g., <code>shared-schemas@1.2.3</code>)</li> </ol> <p>For solo projects or fast-moving MVPs \u2192 tight coupling is fine. For production teams \u2192 use versioning tools like:</p> <ul> <li>Changesets</li> <li>Lerna</li> <li>Private NPM/PyPI registries</li> </ul>"},{"location":"chapter16/#recap-folder-responsibilities","title":"Recap: Folder Responsibilities","text":"Folder Purpose <code>apps/frontend/</code> Vite, React, TSX UI <code>apps/backend/</code> FastAPI app <code>packages/shared-schemas/</code> DTOs, request/response validation <code>packages/gpt-core/</code> Prompt templates, chunking, completions <code>packages/utils/</code> String, token, image utils <code>docker/</code> Container orchestration configs <code>.github/workflows/</code> CI/CD pipelines (monorepo-aware)"},{"location":"chapter16/#summary-monorepos-and-shared-logic","title":"Summary: Monorepos and Shared Logic","text":"Principle Practice Keep everything in one place Use <code>apps/</code> + <code>packages/</code> monorepo model Share schemas and types safely Export DTOs from <code>packages/shared-schemas/</code> Avoid copy-paste logic Extract GPT, OCR, validation logic to shared modules Use smart tooling Turborepo + Poetry + Docker Compose + CI matrix builds Test + version shared logic Keep separate test suites and consider semver tagging <p>Monorepos give you the clarity of modularity with the power of shared logic. This is how real products grow\u2014from prototypes to platforms.</p>"},{"location":"chapter17/","title":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Chapter 17","text":""},{"location":"chapter17/#part-4-hybrid-and-advanced-techniques","title":"Part 4: Hybrid and Advanced Techniques","text":""},{"location":"chapter17/#17-organizing-assets-tests-and-configuration","title":"17. Organizing Assets, Tests, and Configuration","text":"<p>\u201cFolders aren't just for code. They're for everything that keeps your project alive.\u201d</p>"},{"location":"chapter17/#why-this-chapter-matters","title":"Why This Chapter Matters","text":"<p>As your project matures, you\u2019ll deal with more than just components and services. You\u2019ll accumulate:</p> <ul> <li>Images, videos, and static assets</li> <li>Mock data and test fixtures</li> <li>Environment configurations</li> <li>Lint rules, formatters, and pre-commit tools</li> <li>Docs for onboarding and architecture</li> </ul> <p>If these aren't structured well, they rot. If they\u2019re structured intentionally, they accelerate development, testing, and collaboration.</p> <p>This chapter walks you through how to organize the non-code side of your project at scale.</p>"},{"location":"chapter17/#organizing-assets-images-videos-fonts-etc","title":"Organizing Assets: Images, Videos, Fonts, etc.","text":""},{"location":"chapter17/#react-frontend-vite","title":"React Frontend (Vite)","text":"<pre><code>frontend/\n\u251c\u2500\u2500 public/\n\u2502   \u251c\u2500\u2500 logo.svg\n\u2502   \u251c\u2500\u2500 blackhole.webm\n\u2502   \u2514\u2500\u2500 manifest.json\n\u251c\u2500\u2500 src/\n\u2502   \u251c\u2500\u2500 assets/\n\u2502   \u2502   \u251c\u2500\u2500 images/\n\u2502   \u2502   \u251c\u2500\u2500 videos/\n\u2502   \u2502   \u2514\u2500\u2500 fonts/\n</code></pre> Folder Purpose <code>public/</code> Static assets copied directly to <code>/dist/</code> <code>assets/</code> Imported assets via <code>import img from './img.png'</code> <p>Use <code>assets/</code> for:</p> <ul> <li>Project-scoped, importable files (e.g., logo, icons, sounds)</li> <li>CSS-in-JS references</li> <li>Fonts, background videos</li> </ul>"},{"location":"chapter17/#fastapi-backend","title":"FastAPI Backend","text":"<pre><code>backend/\n\u251c\u2500\u2500 static/\n\u2502   \u251c\u2500\u2500 examples/\n\u2502   \u251c\u2500\u2500 uploads/\n\u2502   \u2514\u2500\u2500 docs/\n</code></pre> <p>Mount like this:</p> <pre><code>app.mount(\"/static\", StaticFiles(directory=\"static\"), name=\"static\")\n</code></pre> <p>Common backend assets:</p> <ul> <li>Uploaded files (PDFs, images)</li> <li>OCR outputs</li> <li>Generated previews or processed artifacts</li> </ul>"},{"location":"chapter17/#organizing-tests-and-fixtures","title":"Organizing Tests and Fixtures","text":""},{"location":"chapter17/#folder-patterns","title":"Folder Patterns","text":"<p>Frontend:</p> <pre><code>chatbot/\n\u251c\u2500\u2500 components/\n\u2502   \u2514\u2500\u2500 ChatBox.tsx\n\u251c\u2500\u2500 __tests__/\n\u2502   \u2514\u2500\u2500 ChatBox.test.tsx\n</code></pre> <p>Backend:</p> <pre><code>invoice/\n\u251c\u2500\u2500 services/\n\u2502   \u2514\u2500\u2500 invoice_parser.py\n\u251c\u2500\u2500 __tests__/\n\u2502   \u2514\u2500\u2500 test_invoice_parser.py\n</code></pre> <p>Shared:</p> <pre><code>shared/\n\u251c\u2500\u2500 test_helpers/\n\u2502   \u251c\u2500\u2500 mock_gpt.py\n\u2502   \u251c\u2500\u2500 fake_vectorstore.py\n\u2502   \u2514\u2500\u2500 dummy_files/\n</code></pre> <p>Create <code>dummy_files/</code> for test image uploads, mock PDFs, etc.</p>"},{"location":"chapter17/#feature-based-vs-centralized-testing","title":"Feature-Based vs Centralized Testing","text":"Style When to Use Feature-based (<code>__tests__/</code> in each module) Unit tests, close to logic Centralized (<code>tests/</code> at root) Integration/E2E, CI coverage reports Hybrid (recommended) Use both\u2014fast local tests, full-stack coverage"},{"location":"chapter17/#organizing-environment-files-and-secrets","title":"Organizing Environment Files and Secrets","text":"<p>Use per-app <code>.env</code> files, stored outside of Git.</p> <p>Frontend:</p> <pre><code>.env.development\n.env.production\n</code></pre> <p>Backend:</p> <pre><code>backend/\n\u251c\u2500\u2500 .env\n</code></pre> <p>Use <code>.env.example</code> in your repo for reference:</p> <pre><code># backend/.env.example\nOPENAI_API_KEY=your-key-here\nDATABASE_URL=postgres://...\n</code></pre> <p>Tip: Use secret managers (GCP, Railway, GitHub) for CI environments.</p>"},{"location":"chapter17/#configuration-linting-formatting-git-hooks","title":"Configuration: Linting, Formatting, Git Hooks","text":"<p>Store in root:</p> <pre><code>project-root/\n\u251c\u2500\u2500 .eslintrc.js / .pylintrc\n\u251c\u2500\u2500 .prettierrc / pyproject.toml\n\u251c\u2500\u2500 .editorconfig\n\u251c\u2500\u2500 .gitignore\n\u251c\u2500\u2500 .pre-commit-config.yaml\n</code></pre> <p>Use tools like:</p> <ul> <li>ESLint + Prettier (React)</li> <li>Black, Ruff, or Flake8 (FastAPI)</li> <li><code>pre-commit</code> for Git hook automation (format before commit)</li> <li>Husky (Node) or <code>pre-commit</code> (Python) to enforce standards</li> </ul> <p>Run pre-checks on every PR via CI.</p>"},{"location":"chapter17/#project-documentation","title":"Project Documentation","text":"<p>Create a <code>docs/</code> folder at the root:</p> <pre><code>docs/\n\u251c\u2500\u2500 architecture.md\n\u251c\u2500\u2500 backend-schema.png\n\u251c\u2500\u2500 ai-pipeline.md\n\u251c\u2500\u2500 onboarding.md\n</code></pre> <p>You can also power:</p> <ul> <li>A live developer portal (e.g., Docusaurus)</li> <li>MkDocs (<code>mkdocs.yml</code>)</li> <li>README embeds with diagrams</li> </ul> <p>Tip: Store architectural diagrams (e.g., GPT + vector flow) alongside Markdown files using tools like Excalidraw or Diagrams.net.</p>"},{"location":"chapter17/#bonus-folder-conventions-for-miscellaneous-concerns","title":"Bonus: Folder Conventions for Miscellaneous Concerns","text":"Folder Purpose <code>scripts/</code> One-off migration scripts, utility CLI scripts <code>jobs/</code> Scheduled background tasks or cronjobs <code>migrations/</code> Alembic or Prisma-style DB migrations <code>k8s/</code> or <code>infra/</code> IaC configs for staging/prod <code>mock-data/</code> JSON/CSV test data for manual frontend mocking"},{"location":"chapter17/#summary-organizational-hygiene-at-scale","title":"Summary: Organizational Hygiene at Scale","text":"Concern Best Practice Static assets Use <code>public/</code> and <code>assets/</code> clearly Feature tests Use <code>__tests__/</code> per module Integration tests Centralize under <code>tests/</code> or <code>e2e/</code> Mocks and test files Store in <code>test_helpers/</code> or <code>dummy_files/</code> Env vars Use <code>.env</code>, ignore real keys, commit <code>.env.example</code> Docs Store architecture, onboarding, diagrams in <code>docs/</code> Config Keep linters, formatters, pre-commit in project root <p>This isn\u2019t \u201cjust organization.\u201d It\u2019s about reducing friction as your team and product grow.</p>"},{"location":"chapter18/","title":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Chapter 18","text":""},{"location":"chapter18/#part-4-hybrid-and-advanced-techniques","title":"Part 4: Hybrid and Advanced Techniques","text":""},{"location":"chapter18/#18-migration-playbook","title":"18. Migration Playbook","text":"<p>\u201cStructure isn\u2019t something you start with. It\u2019s something you grow into\u2014intentionally.\u201d</p>"},{"location":"chapter18/#why-migration-matters","title":"Why Migration Matters","text":"<p>Most teams don\u2019t start with a perfect folder structure. They start with:</p> <ul> <li><code>src/components/</code>, <code>api.js</code>, and <code>utils.js</code></li> <li>A backend with 800-line <code>main.py</code></li> <li><code>test/</code> as a dumping ground for broken fixtures</li> </ul> <p>This chapter teaches you how to migrate from flat \u2192 modular \u2192 scalable without fear.</p> <p>Migration is not a one-shot effort. It\u2019s a guided evolution\u2014powered by patterns and audit discipline.</p>"},{"location":"chapter18/#3-stage-evolution","title":"3-Stage Evolution","text":"Stage Description When It Breaks Flat Everything in one or two folders (<code>src/</code>, <code>api/</code>) 5+ features, unclear ownership Modular Feature-first folders (<code>chatbot/</code>, <code>invoice/</code>) Shared logic begins to duplicate Scalable Layered global logic (<code>services/</code>, <code>core/</code>, <code>infra/</code>) Team scaling, cross-feature demands <p>You don\u2019t need to jump to \u201centerprise mode\u201d overnight. Instead, migrate feature-by-feature, backed by rules and refactors.</p>"},{"location":"chapter18/#folder-audit-checklist","title":"Folder Audit Checklist","text":"<p>Before refactoring, audit your project with this checklist:</p>"},{"location":"chapter18/#flat-signs-of-trouble","title":"Flat Signs of Trouble:","text":"<ul> <li>50+ files inside <code>src/</code></li> <li><code>utils.js</code> is over 300 lines</li> <li>Route handlers and business logic mixed</li> <li>Tests refer to multiple features</li> <li>Files are hard to discover (\u201cWhere\u2019s that PDF upload again?\u201d)</li> </ul>"},{"location":"chapter18/#migration-candidates","title":"Migration Candidates:","text":"<ul> <li>GPT logic used by both chatbot and invoice modules</li> <li>OCR parsing duplicated across endpoints</li> <li>Shared data models scattered across files</li> <li>Components reused in 3+ pages</li> </ul> <p>If you said \u201cyes\u201d to any \u2192 you\u2019re ready to modularize or extract shared logic.</p>"},{"location":"chapter18/#safe-refactor-patterns","title":"Safe Refactor Patterns","text":""},{"location":"chapter18/#1-extract-to-services-or-shared","title":"1. Extract to <code>services/</code> or <code>shared/</code>","text":"<ul> <li>Take a well-known utility or GPT function</li> <li>Move it to <code>/services/gpt.py</code> or <code>/shared/gptService.ts</code></li> <li>Refactor just one feature to use it first</li> </ul>"},{"location":"chapter18/#2-use-aliases-or-absolute-imports","title":"2. Use Aliases or Absolute Imports","text":"<ul> <li>Instead of <code>../../../shared/utils.py</code>, use:</li> </ul> <pre><code>import { formatTokens } from \"@shared/gpt\"\n</code></pre> <pre><code>from shared.utils.gpt import format_tokens\n</code></pre> <p>Update <code>vite.config.ts</code>, <code>pyrightconfig.json</code>, or <code>PYTHONPATH</code> accordingly.</p>"},{"location":"chapter18/#3-extract-mock","title":"3. Extract &amp; Mock","text":"<ul> <li>Extract shared logic</li> <li>Temporarily mock it in tests to avoid full rewrites</li> </ul> <pre><code>vi.mock(\"@shared/gpt\", () =&gt; ({\n  generateResponse: vi.fn(() =&gt; \"mocked\")\n}))\n</code></pre>"},{"location":"chapter18/#4-strangle-the-monolith","title":"4. Strangle-the-Monolith","text":"<p>Refactor a feature one layer at a time:</p> <ol> <li>Move <code>routes/</code></li> <li>Move <code>services/</code></li> <li>Move <code>schemas/</code></li> <li>Migrate tests</li> </ol> <p>Repeat per feature.</p>"},{"location":"chapter18/#common-migration-mistakes","title":"Common Migration Mistakes","text":"Mistake Safer Alternative Massive refactor PR Refactor per module or layer Duplicate logic then forget to remove old Use TODO comments and GitHub issues Break imports globally Use safe alias migration (<code>vite.config.ts</code>, <code>PYTHONPATH</code>) Remove tests during cleanup Keep old tests running until migration is verified Refactor unneeded files Prioritize high-traffic or high-duplication areas <p>You\u2019re not chasing perfection. You\u2019re building momentum.</p>"},{"location":"chapter18/#refactor-safe-naming-conventions","title":"Refactor-Safe Naming Conventions","text":"<p>Use consistent names so that features and shared logic are immediately obvious.</p> Folder Naming Pattern <code>services/</code> <code>gpt_service.py</code>, <code>ocr_parser.ts</code>, <code>vector_client.py</code> <code>features/</code> <code>chatbot/</code>, <code>invoice/</code>, <code>upload/</code> <code>schemas/</code> <code>chat.py</code>, <code>invoice.py</code>, <code>shared.py</code> <code>__tests__/</code> <code>test_&lt;module&gt;.py</code> or <code>&lt;Component&gt;.test.tsx</code> <code>docs/</code> <code>architecture.md</code>, <code>auth-flow.png</code> <p>Use underscores for Python, camelCase or PascalCase for TypeScript.</p>"},{"location":"chapter18/#cicd-considerations-after-migration","title":"CI/CD Considerations After Migration","text":""},{"location":"chapter18/#split-buildtest-pipelines","title":"Split build/test pipelines:","text":"<ul> <li>Use matrix builds per folder (<code>frontend</code>, <code>backend</code>)</li> <li>Cache shared packages (<code>packages/</code>)</li> </ul>"},{"location":"chapter18/#set-up-folder-watchers","title":"Set up folder watchers:","text":"<ul> <li>Rebuild only affected layers</li> <li>GitHub Actions:</li> </ul> <pre><code>paths:\n  - \"apps/frontend/**\"\n  - \"packages/shared-schemas/**\"\n</code></pre>"},{"location":"chapter18/#test-the-structure","title":"Test the structure:","text":"<ul> <li>Run <code>tree -L 3</code> or use <code>code-stats</code> CLI to visualize folder shape</li> <li>Confirm your <code>README.md</code> shows updated structure + dev flow</li> </ul>"},{"location":"chapter18/#migration-summary","title":"Migration Summary","text":"Phase Action Audit Identify bloated files, duplicated logic, cross-feature coupling Stage 1 Move to feature folders: <code>chatbot/</code>, <code>invoice/</code> Stage 2 Extract shared GPT, OCR, and services to global layers Stage 3 Add testing strategies, docs, and versioned API structure Maintain Lock in CI pipelines and developer onboarding docs <p>Folder structure is the interface your team uses daily. Migration isn\u2019t cleanup\u2014it\u2019s optimization.</p> <p>You now have a full framework for evolving any project into a modular, scalable, and maintainable system.</p>"},{"location":"chapter19/","title":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Chapter 19","text":""},{"location":"chapter19/#part-5-case-studies-and-templates","title":"Part 5: Case Studies and Templates","text":""},{"location":"chapter19/#19-case-study-smart-receipt-invoice-analyzer","title":"19. Case Study: Smart Receipt / Invoice Analyzer","text":"<p>\u201cOCR is messy. Accounting rules are worse. But structure makes sense of both.\u201d</p>"},{"location":"chapter19/#overview","title":"Overview","text":"<p>The Smart Receipt/Invoice Analyzer is a full-stack AI application that:</p> <ul> <li>Accepts images or PDFs of receipts and invoices</li> <li>Performs OCR (Optical Character Recognition)</li> <li>Extracts structured fields (merchant, total, date, tax)</li> <li>Parses text into key-value data using GPT</li> <li>Allows frontend edits + corrections</li> <li>Stores parsed data in a database</li> </ul> <p>This is a perfect case to demonstrate:</p> <ul> <li>Modular architecture for isolated AI pipelines</li> <li>Clean foldering for OCR, GPT, and DB services</li> <li>How to evolve from modular \u2192 hybrid structure</li> </ul>"},{"location":"chapter19/#initial-modular-structure","title":"Initial Modular Structure","text":"<p>We began with a feature-first modular approach.</p>"},{"location":"chapter19/#frontend-react-vite","title":"Frontend (React + Vite)","text":"<pre><code>frontend/\n\u2514\u2500\u2500 src/\n    \u2514\u2500\u2500 features/\n        \u2514\u2500\u2500 invoice/\n            \u251c\u2500\u2500 components/\n            \u2502   \u251c\u2500\u2500 UploadForm.tsx\n            \u2502   \u2514\u2500\u2500 ParsedPreview.tsx\n            \u251c\u2500\u2500 hooks/\n            \u2502   \u2514\u2500\u2500 useUpload.ts\n            \u251c\u2500\u2500 services/\n            \u2502   \u2514\u2500\u2500 invoiceApi.ts\n            \u2514\u2500\u2500 types/\n                \u2514\u2500\u2500 InvoiceFields.ts\n</code></pre>"},{"location":"chapter19/#backend-fastapi","title":"Backend (FastAPI)","text":"<pre><code>backend/\n\u2514\u2500\u2500 app/\n    \u2514\u2500\u2500 features/\n        \u2514\u2500\u2500 invoice/\n            \u251c\u2500\u2500 routes.py\n            \u251c\u2500\u2500 services/\n            \u2502   \u251c\u2500\u2500 ocr_service.py\n            \u2502   \u2514\u2500\u2500 gpt_parser.py\n            \u251c\u2500\u2500 schemas/\n            \u2502   \u2514\u2500\u2500 invoice.py\n            \u2514\u2500\u2500 models.py\n</code></pre> <p>Each feature folder handled everything it needed:</p> <ul> <li>Frontend: form, preview, upload logic</li> <li>Backend: OCR, parsing, validation, and response shaping</li> </ul>"},{"location":"chapter19/#evolution-to-hybrid-structure","title":"Evolution to Hybrid Structure","text":"<p>Once we added:</p> <ul> <li>Chatbot module that also needed OCR</li> <li>Document classification logic for PDFs</li> </ul> <p>We extracted shared logic into global services.</p>"},{"location":"chapter19/#new-shared-backend-structure","title":"New Shared Backend Structure","text":"<pre><code>backend/\n\u251c\u2500\u2500 app/\n\u2502   \u251c\u2500\u2500 features/\n\u2502   \u2502   \u2514\u2500\u2500 invoice/\n\u2502   \u251c\u2500\u2500 services/\n\u2502   \u2502   \u251c\u2500\u2500 ocr_engine.py         # Shared OCR logic (Tesseract, PaddleOCR)\n\u2502   \u2502   \u251c\u2500\u2500 gpt_client.py         # Central GPT communication layer\n\u2502   \u2502   \u2514\u2500\u2500 file_utils.py\n\u2502   \u2514\u2500\u2500 schemas/\n\u2502       \u2514\u2500\u2500 shared.py\n</code></pre> <p>Now:</p> <ul> <li>Any feature can call <code>ocr_engine.extract_text(file)</code></li> <li>GPT prompts are templated and reused across modules</li> </ul>"},{"location":"chapter19/#testing-breakdown","title":"Testing Breakdown","text":""},{"location":"chapter19/#unit-tests","title":"Unit Tests","text":"<pre><code>tests/\n\u2514\u2500\u2500 invoice/\n    \u251c\u2500\u2500 test_parser.py\n    \u251c\u2500\u2500 test_ocr.py\n    \u2514\u2500\u2500 test_routes.py\n</code></pre>"},{"location":"chapter19/#mocks","title":"Mocks","text":"<pre><code>shared/test_helpers/\n\u251c\u2500\u2500 fake_invoice_image.png\n\u2514\u2500\u2500 mock_gpt.py\n</code></pre> <p>Mocking GPT + OCR was essential to keep test speed fast and predictable.</p>"},{"location":"chapter19/#tech-stack-snapshot","title":"Tech Stack Snapshot","text":"Layer Tool OCR Tesseract / PaddleOCR LLM OpenAI GPT-3.5 / GPT-4 Backend FastAPI Frontend React + Vite State React Context Deployment Railway + Vercel DB Supabase (PostgreSQL) Auth JWT (Backend) + Supabase Auth (Frontend)"},{"location":"chapter19/#key-lessons","title":"Key Lessons","text":"Challenge Resolution GPT prompts reused in multiple modules Moved prompt logic to <code>services/gpt_client.py</code> OCR used across invoice/chatbot features Created <code>ocr_engine.py</code> in shared service layer Uploads had differing file handling logic Created <code>file_utils.py</code> with unified image/PDF handlers Type duplication between front and back Introduced <code>packages/shared-schemas/</code> in monorepo Components growing too large Split into <code>UploadForm</code>, <code>FieldPreview</code>, <code>ErrorBanner</code> Test bloat in one location Adopted hybrid test structure (feature + root tests)"},{"location":"chapter19/#final-hybrid-folder-snapshot","title":"Final Hybrid Folder Snapshot","text":""},{"location":"chapter19/#backend","title":"Backend:","text":"<pre><code>app/\n\u251c\u2500\u2500 features/\n\u2502   \u2514\u2500\u2500 invoice/\n\u2502       \u251c\u2500\u2500 routes.py\n\u2502       \u251c\u2500\u2500 services/\n\u2502       \u2514\u2500\u2500 schemas/\n\u251c\u2500\u2500 services/\n\u2502   \u251c\u2500\u2500 gpt_client.py\n\u2502   \u251c\u2500\u2500 ocr_engine.py\n\u2502   \u2514\u2500\u2500 file_utils.py\n\u251c\u2500\u2500 schemas/\n\u2502   \u2514\u2500\u2500 shared.py\n</code></pre>"},{"location":"chapter19/#frontend","title":"Frontend:","text":"<pre><code>src/\n\u251c\u2500\u2500 features/\n\u2502   \u2514\u2500\u2500 invoice/\n\u2502       \u251c\u2500\u2500 components/\n\u2502       \u251c\u2500\u2500 services/\n\u2502       \u2514\u2500\u2500 hooks/\n\u251c\u2500\u2500 shared/\n\u2502   \u2514\u2500\u2500 utils/\n\u2502       \u2514\u2500\u2500 filePreview.ts\n</code></pre>"},{"location":"chapter19/#project-outcomes","title":"Project Outcomes","text":"<ul> <li>100+ invoices processed in a demo database</li> <li>Accurate OCR + GPT parsing of total/tax/date in 90% of test cases</li> <li>Scalable architecture allowed new features (chatbot, classifier) to be added without breaking invoice logic</li> <li>Deployed to Vercel + Railway with monorepo CI/CD</li> </ul>"},{"location":"chapter19/#what-this-case-proves","title":"What This Case Proves","text":"<p>This case demonstrates:</p> <p>\u2705 How to bootstrap modularly with minimal complexity \u2705 When and how to extract shared AI logic (OCR, GPT) \u2705 How to support multi-feature AI pipelines in a clean structure \u2705 The power of hybrid folder strategies for AI-driven apps</p>"},{"location":"chapter2/","title":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Chapter 2","text":""},{"location":"chapter2/#part-1-foundations","title":"Part 1: Foundations","text":""},{"location":"chapter2/#2-why-folder-structure-matters","title":"2. Why Folder Structure Matters","text":"<p>\u201cWe didn\u2019t plan to build a mess. But we didn\u2019t plan not to, either.\u201d</p>"},{"location":"chapter2/#anatomy-of-growing-software-chaos","title":"Anatomy of Growing Software Chaos","text":"<p>Most projects don\u2019t start messy\u2014they become messy.</p> <p>At the beginning, you have:</p> <ul> <li>One feature</li> <li>One or two files</li> <li>A clear mental model</li> </ul> <p>But then come the deadlines. The integrations. The second developer. The new AI use case. The client request. The pivot. The third-party library. The \u201cquick fix.\u201d</p> <p>Suddenly:</p> <ul> <li>APIs and components blur together.</li> <li>Tests feel optional\u2014or worse, unfindable.</li> <li>The <code>utils</code> folder has 48 unrelated files and no README.</li> <li>Every new developer asks where things are.</li> <li>And you're scared to delete anything because you don\u2019t know what might break.</li> </ul> <p>This is the silent chaos that folder structure is supposed to prevent. Not with magic\u2014but with intentional design.</p>"},{"location":"chapter2/#real-world-symptoms-of-bad-structure","title":"Real-World Symptoms of Bad Structure","text":"<p>How do you know when your project structure is hurting you?</p> <p>Here are the symptoms:</p> <ul> <li> <p>You duplicate code without realizing it.   Because reusing it would require understanding a tangled mess.</p> </li> <li> <p>New features require touching files in 5+ different folders.   Because logic is scattered across layer-less chaos.</p> </li> <li> <p>Tests don\u2019t reflect features.   Because your test folder is divorced from the real structure of your app.</p> </li> <li> <p>Debugging is a scavenger hunt.   Because there\u2019s no clear \u201centry point\u201d or flow to trace logic.</p> </li> <li> <p>You hesitate to refactor.   Because nothing feels isolated. Every small change risks side effects.</p> </li> <li> <p>Hiring slows down.   Because onboarding takes weeks, not days. No one understands \u201cthe structure.\u201d</p> </li> </ul> <p>It\u2019s not always about code quality\u2014it\u2019s about code navigation. And poor structure breaks cognitive flow before it breaks the app.</p>"},{"location":"chapter2/#structure-as-an-extension-of-architecture","title":"Structure as an Extension of Architecture","text":"<p>Architecture is the big picture\u2014how systems talk, how layers interact. Folder structure is the concrete expression of that architecture.</p> <p>A good structure answers:</p> <ul> <li>Where do I add a new feature?</li> <li>Where does the API logic go?</li> <li>How do I keep GPT integration isolated from UI logic?</li> <li>How do modules share logic without creating coupling?</li> <li>Where does a new developer start reading?</li> </ul> <p>It\u2019s not just about clarity for humans\u2014it\u2019s also about:</p> <ul> <li>Dependency control</li> <li>File change traceability</li> <li>CI/CD build optimization</li> <li>Test coverage mapping</li> <li>Code ownership and modular deployability</li> </ul> <p>Structure isn\u2019t just organization. It\u2019s intentional friction that guides how code evolves.</p>"},{"location":"chapter2/#structure-affects-every-phase-of-development","title":"Structure Affects Every Phase of Development","text":"<p>Let\u2019s break it down by lifecycle:</p> Phase Impact of Folder Structure Development Easier to write, debug, and navigate code Testing Tests live close to the logic they test; mocking is localized Collaboration Clear boundaries for ownership and parallel work Refactoring Confidence to isolate, rewrite, or remove features CI/CD &amp; Deployment Layered folders enable smart builds and faster pipelines Onboarding New developers can see how the app is designed"},{"location":"chapter2/#why-folder-structure-is-more-than-personal-preference","title":"Why Folder Structure is More Than Personal Preference","text":"<p>Some devs say, \u201cFolder structure is subjective.\u201d That\u2019s true\u2014until it costs you time, bugs, or trust.</p> <p>The difference between a good and bad structure isn\u2019t aesthetics. It\u2019s operational clarity.</p> <ul> <li>Can new devs understand the app by looking at folders?</li> <li>Can you remove a feature without breaking another?</li> <li>Can two teams work on the same repo without collisions?</li> <li>Can AI features like OCR, GPT calls, and vector DB logic be isolated and reused?</li> </ul> <p>These aren\u2019t theoretical concerns. They define your ability to move fast without breaking things.</p>"},{"location":"chapter2/#planning-for-change","title":"Planning for Change","text":"<p>Structure is not for now\u2014it\u2019s for later.</p> <p>The right question isn\u2019t \u201cwhat works today?\u201d It\u2019s:</p> <p>How will this structure hold up when we double the features, triple the team, and introduce a second AI pipeline?</p> <p>The best folder structures are not just tidy. They\u2019re resilient to growth.</p>"},{"location":"chapter20/","title":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Chapter 20","text":""},{"location":"chapter20/#part-5-case-studies-and-templates","title":"Part 5: Case Studies and Templates","text":""},{"location":"chapter20/#20-case-study-document-intelligence-chatbot","title":"20. Case Study: Document Intelligence Chatbot","text":"<p>\u201cYou don't just answer questions. You reason across pages, paragraphs, and payloads.\u201d</p>"},{"location":"chapter20/#overview","title":"Overview","text":"<p>The Document Intelligence Chatbot is a full-stack RAG-powered AI assistant that allows users to:</p> <ul> <li>Upload documents (PDFs, images, DOCX)</li> <li>Run OCR (if needed) on non-text files</li> <li>Split and embed text into a vector database</li> <li>Query via a chatbot interface using GPT</li> <li>Retrieve, synthesize, and stream document-aware answers</li> </ul> <p>This project sits at the intersection of:</p> <ul> <li>NLP, embeddings, and chunking</li> <li>File handling and background processing</li> <li>Realtime chat UI and long-context memory</li> <li>Vector DBs and API orchestration</li> </ul>"},{"location":"chapter20/#initial-scalable-structure-from-day-one","title":"Initial Scalable Structure (from day one)","text":"<p>Unlike the Invoice Analyzer, this project started with scale in mind.</p>"},{"location":"chapter20/#backend-fastapi","title":"Backend (FastAPI)","text":"<pre><code>backend/\n\u251c\u2500\u2500 app/\n\u2502   \u251c\u2500\u2500 api/\n\u2502   \u2502   \u251c\u2500\u2500 chat.py\n\u2502   \u2502   \u2514\u2500\u2500 upload.py\n\u2502   \u251c\u2500\u2500 services/\n\u2502   \u2502   \u251c\u2500\u2500 ocr_engine.py\n\u2502   \u2502   \u251c\u2500\u2500 gpt_client.py\n\u2502   \u2502   \u251c\u2500\u2500 chunker.py\n\u2502   \u2502   \u251c\u2500\u2500 embedding.py\n\u2502   \u2502   \u2514\u2500\u2500 retriever.py\n\u2502   \u251c\u2500\u2500 schemas/\n\u2502   \u2502   \u251c\u2500\u2500 chat.py\n\u2502   \u2502   \u2514\u2500\u2500 document.py\n\u2502   \u251c\u2500\u2500 vectorstore/\n\u2502   \u2502   \u2514\u2500\u2500 supabase.py\n\u2502   \u2514\u2500\u2500 core/\n\u2502       \u251c\u2500\u2500 config.py\n\u2502       \u2514\u2500\u2500 logging.py\n</code></pre>"},{"location":"chapter20/#frontend-react-vite","title":"Frontend (React + Vite)","text":"<pre><code>frontend/\n\u2514\u2500\u2500 src/\n    \u251c\u2500\u2500 features/\n    \u2502   \u251c\u2500\u2500 chat/\n    \u2502   \u2514\u2500\u2500 upload/\n    \u251c\u2500\u2500 components/\n    \u2502   \u251c\u2500\u2500 ChatBox.tsx\n    \u2502   \u251c\u2500\u2500 FileDropZone.tsx\n    \u2502   \u2514\u2500\u2500 StreamingBubble.tsx\n    \u251c\u2500\u2500 services/\n    \u2502   \u2514\u2500\u2500 apiClient.ts\n    \u251c\u2500\u2500 hooks/\n    \u2502   \u2514\u2500\u2500 useStreamingChat.ts\n    \u2514\u2500\u2500 shared/\n        \u2514\u2500\u2500 utils/\n            \u2514\u2500\u2500 chunkPreview.ts\n</code></pre>"},{"location":"chapter20/#core-ai-flow","title":"Core AI Flow","text":"<pre><code>[Upload Document]\n    \u2193\nOCR (if needed)\n    \u2193\nText Chunking\n    \u2193\nEmbeddings \u2192 Supabase (pgvector)\n    \u2193\n[Ask Question]\n    \u2193\nQuery Vector DB\n    \u2193\nPass relevant chunks to GPT\n    \u2193\nStream answer token-by-token\n    \u2193\n[Render Chat UI]\n</code></pre>"},{"location":"chapter20/#testing-breakdown","title":"Testing Breakdown","text":""},{"location":"chapter20/#unit-tests","title":"Unit Tests","text":"<pre><code>tests/\n\u251c\u2500\u2500 services/\n\u2502   \u251c\u2500\u2500 test_ocr_engine.py\n\u2502   \u251c\u2500\u2500 test_chunker.py\n\u2502   \u2514\u2500\u2500 test_embedding.py\n</code></pre>"},{"location":"chapter20/#integration-tests","title":"Integration Tests","text":"<pre><code>tests/\n\u251c\u2500\u2500 api/\n\u2502   \u251c\u2500\u2500 test_chat.py\n\u2502   \u2514\u2500\u2500 test_upload.py\n</code></pre>"},{"location":"chapter20/#mocks","title":"Mocks","text":"<pre><code>shared/test_helpers/\n\u251c\u2500\u2500 mock_pdf.pdf\n\u251c\u2500\u2500 fake_embeddings.json\n\u2514\u2500\u2500 mock_gpt_response.py\n</code></pre>"},{"location":"chapter20/#architectural-wins","title":"Architectural Wins","text":"Problem Solution Mixing OCR and GPT in one pipeline Broke into <code>ocr_engine.py</code> and <code>gpt_client.py</code> Need for streaming chat responses Used FastAPI\u2019s <code>StreamingResponse</code> with async token yield Scattered vector DB logic Moved to <code>vectorstore/supabase.py</code> as a wrapper Complex GPT prompts per feature Template-driven prompts in <code>prompts/</code> or inline Jinja Upload race conditions Background task queue (e.g., Celery or FastAPI background task) Slow test speed due to real GPT Replaced with <code>mock_gpt_response.py</code> + snapshot tests"},{"location":"chapter20/#deployment-stack","title":"Deployment Stack","text":"Layer Tool Backend FastAPI (hosted on Render) Frontend React + Vite (deployed to Netlify) Chat LLM OpenAI GPT-4 via streaming Vector DB Supabase with <code>pgvector</code> Storage Supabase Buckets OCR PaddleOCR (fallback to Tesseract) Embedding Model <code>text-embedding-3-small</code> CI/CD GitHub Actions + PR checks"},{"location":"chapter20/#dev-experience-enhancements","title":"Dev Experience Enhancements","text":"<ul> <li>Local <code>.env</code> loaded via <code>dotenv</code> with fallback to Render secrets</li> <li>Tailwind UI for fast design of chat &amp; file upload zones</li> <li>Monorepo setup using <code>pnpm workspaces</code> with:</li> </ul> <pre><code>  apps/\n    \u251c\u2500\u2500 frontend/\n    \u2514\u2500\u2500 backend/\n  packages/\n    \u2514\u2500\u2500 shared-schemas/\n</code></pre>"},{"location":"chapter20/#edge-case-handlings","title":"Edge Case Handlings","text":"Edge Case Resolution PDF upload with no text layer OCR fallback with PaddleOCR Image uploads with handwriting Post-OCR cleanup with regex correction GPT context overflow Auto-summarization of long chunks Broken token stream Frontend <code>AbortController</code> with retry Multi-document queries Multi-file embedding tracking with <code>document_id</code> tagging"},{"location":"chapter20/#final-structure-snapshot","title":"Final Structure Snapshot","text":""},{"location":"chapter20/#backend","title":"Backend:","text":"<pre><code>app/\n\u251c\u2500\u2500 api/\n\u2502   \u2514\u2500\u2500 chat.py\n\u251c\u2500\u2500 services/\n\u2502   \u251c\u2500\u2500 ocr_engine.py\n\u2502   \u251c\u2500\u2500 embedding.py\n\u2502   \u2514\u2500\u2500 retriever.py\n\u251c\u2500\u2500 vectorstore/\n\u2502   \u2514\u2500\u2500 supabase.py\n\u251c\u2500\u2500 schemas/\n\u2502   \u2514\u2500\u2500 chat.py\n\u251c\u2500\u2500 prompts/\n\u2502   \u2514\u2500\u2500 rag_template.txt\n</code></pre>"},{"location":"chapter20/#frontend","title":"Frontend:","text":"<pre><code>src/\n\u251c\u2500\u2500 features/\n\u2502   \u251c\u2500\u2500 upload/\n\u2502   \u2514\u2500\u2500 chat/\n\u251c\u2500\u2500 components/\n\u2502   \u251c\u2500\u2500 ChatBox.tsx\n\u2502   \u2514\u2500\u2500 StreamingBubble.tsx\n\u251c\u2500\u2500 hooks/\n\u2502   \u2514\u2500\u2500 useStreamingChat.ts\n</code></pre>"},{"location":"chapter20/#outcomes","title":"Outcomes","text":"<ul> <li>Real-time chat performance with \\~2s latency</li> <li>GPT answers grounded in actual user documents</li> <li>92%+ retrieval accuracy via <code>text-embedding-3-small</code></li> <li>Horizontal scalability with Render\u2019s autoscaling + pgvector indexing</li> <li>Successfully demoed for 3 different use cases (contracts, academic PDFs, invoices)</li> </ul>"},{"location":"chapter20/#key-takeaways","title":"Key Takeaways","text":"<p>\u2705 Build scalable from the start if the product involves multiple AI pipelines \u2705 Use dedicated service layers to isolate OCR, GPT, chunking, and vector logic \u2705 Design frontend UX-first to support streaming and async behaviors \u2705 Leverage Supabase + FastAPI for full open-source vertical integration \u2705 Embrace modular tests, mocks, and monitoring as part of the structure</p>"},{"location":"chapter21/","title":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Chapter 21","text":""},{"location":"chapter21/#part-5-case-studies-and-templates","title":"Part 5: Case Studies and Templates","text":""},{"location":"chapter21/#21-case-study-ai-powered-mockup-to-code-tool","title":"21. Case Study: AI-Powered Mockup-to-Code Tool","text":"<p>\u201cA mockup isn\u2019t just a picture. It\u2019s a latent interface waiting to be decoded.\u201d</p>"},{"location":"chapter21/#overview","title":"Overview","text":"<p>The AI-Powered Mockup-to-Code Tool is a frontend-first AI application that transforms UI mockups (Figma exports, PNGs, screenshots) into structured HTML/CSS or React components.</p> <p>The pipeline involves:</p> <ul> <li>Uploading a mockup image</li> <li>Performing layout analysis using vision models</li> <li>Extracting UI elements and classifying them (buttons, input fields, headers, etc.)</li> <li>Generating code snippets (React or Tailwind-based) via GPT</li> <li>Displaying a live preview and downloadable scaffold</li> </ul> <p>This project demonstrates:</p> <p>\u2705 Cross-domain AI integration (CV + LLM) \u2705 Highly interactive frontend logic \u2705 Modular and layered backend orchestration \u2705 Clear separation of vision pipeline and code generation</p>"},{"location":"chapter21/#initial-modular-structure","title":"Initial Modular Structure","text":"<p>The project started modular for experimentation, especially for isolating layout detection and prompt engineering.</p>"},{"location":"chapter21/#frontend-react-vite","title":"Frontend (React + Vite)","text":"<pre><code>src/\n\u2514\u2500\u2500 features/\n    \u251c\u2500\u2500 upload/\n    \u251c\u2500\u2500 preview/\n    \u2514\u2500\u2500 codegen/\n</code></pre>"},{"location":"chapter21/#backend-fastapi","title":"Backend (FastAPI)","text":"<pre><code>app/\n\u2514\u2500\u2500 features/\n    \u251c\u2500\u2500 layout/\n    \u251c\u2500\u2500 codegen/\n    \u2514\u2500\u2500 upload/\n</code></pre>"},{"location":"chapter21/#final-scalable-hybrid-structure","title":"Final Scalable Hybrid Structure","text":"<p>As accuracy and user demand increased, shared services emerged across modules, triggering a hybrid structure shift.</p>"},{"location":"chapter21/#backend","title":"Backend:","text":"<pre><code>app/\n\u251c\u2500\u2500 api/\n\u2502   \u251c\u2500\u2500 upload.py\n\u2502   \u251c\u2500\u2500 layout.py\n\u2502   \u2514\u2500\u2500 codegen.py\n\u251c\u2500\u2500 services/\n\u2502   \u251c\u2500\u2500 image_processing.py\n\u2502   \u251c\u2500\u2500 layout_detector.py\n\u2502   \u251c\u2500\u2500 gpt_prompt_builder.py\n\u2502   \u2514\u2500\u2500 html_generator.py\n\u251c\u2500\u2500 schemas/\n\u2502   \u251c\u2500\u2500 layout.py\n\u2502   \u2514\u2500\u2500 codegen.py\n\u251c\u2500\u2500 core/\n\u2502   \u2514\u2500\u2500 config.py\n</code></pre>"},{"location":"chapter21/#frontend","title":"Frontend:","text":"<pre><code>src/\n\u251c\u2500\u2500 components/\n\u2502   \u251c\u2500\u2500 MockupCanvas.tsx\n\u2502   \u251c\u2500\u2500 LayoutBoundingBox.tsx\n\u2502   \u2514\u2500\u2500 CodePreview.tsx\n\u251c\u2500\u2500 services/\n\u2502   \u2514\u2500\u2500 codegenClient.ts\n\u251c\u2500\u2500 hooks/\n\u2502   \u2514\u2500\u2500 useCodeGeneration.ts\n\u251c\u2500\u2500 features/\n\u2502   \u251c\u2500\u2500 upload/\n\u2502   \u251c\u2500\u2500 detect/\n\u2502   \u2514\u2500\u2500 render/\n</code></pre>"},{"location":"chapter21/#core-ai-flow","title":"Core AI Flow","text":"<pre><code>[Image Upload]\n    \u2193\nCV Layout Detection (YOLO or Detectron2)\n    \u2193\nComponent Classification (headers, buttons, divs)\n    \u2193\nPrompt Assembly \u2192 GPT-4\n    \u2193\nCode Output (React + Tailwind / HTML + CSS)\n    \u2193\n[Live Preview + Download]\n</code></pre>"},{"location":"chapter21/#cv-gpt-model-integration","title":"CV + GPT Model Integration","text":"Step Tech Object detection YOLOv8 or Detectron2 (trained on UIs) Component label classification Custom CV classifier Prompt injection GPT-4 via OpenAI API Code formatting Prettier (client-side) Model inference Hosted on Replicate (for YOLO) or local PyTorch"},{"location":"chapter21/#testing-approach","title":"Testing Approach","text":"Layer Strategy Layout detector Snapshot-based CV test (bounding boxes) GPT prompt Deterministic unit tests with static inputs Frontend Visual regression tests (Storybook + Playwright) Upload/codegen endpoints End-to-end integration with sample assets"},{"location":"chapter21/#key-problems-fixes","title":"Key Problems &amp; Fixes","text":"Problem Resolution LLM-generated code sometimes invalid Added static HTML validator + auto-fix layer Misclassified layout regions Introduced confidence thresholding + post-processing rules Slow image inference on render Added async loading + placeholder thumbnails GPT prompt bloated for large mockups Chunked component zones and stitched final code Loss of user layout intent Allowed user to manually adjust box types before codegen"},{"location":"chapter21/#frontend-interaction-flow","title":"Frontend Interaction Flow","text":"<ol> <li>User uploads mockup image  </li> <li>Bounding boxes appear with labels (adjustable)  </li> <li>User selects preferred framework (HTML/CSS or React/Tailwind)  </li> <li>\u201cGenerate Code\u201d triggers GPT prompt call  </li> <li>Code appears in preview pane + download button enabled</li> </ol>"},{"location":"chapter21/#tech-stack-summary","title":"Tech Stack Summary","text":"Layer Tool CV Inference YOLOv8 (Replicate or local Torch) GPT Codegen GPT-4 (OpenAI API) Frontend React + Tailwind CSS State Zustand (for image + code state) Formatter Prettier (optional: ESLint) Deployment Netlify + Railway Previews Monaco Editor + HTML live iframe"},{"location":"chapter21/#outcomes","title":"Outcomes","text":"<ul> <li>Converted mockups to usable React code in &lt;15 seconds</li> <li>Allowed manual overrides on labels before GPT input</li> <li>Reduced layout hallucination via hybrid prompt template</li> <li>Supported 2 output modes: HTML/CSS and React + Tailwind</li> <li>Used by junior frontend devs as a scaffolding tool</li> </ul>"},{"location":"chapter21/#what-this-case-demonstrates","title":"What This Case Demonstrates","text":"<p>\u2705 Vision pipeline and GPT codegen must be decoupled \u2705 Hybrid prompting is more stable than pure freeform GPT \u2705 Component previewing and user correction is vital \u2705 Modular frontend separation (upload / detect / render) improves UX \u2705 Shared CV and GPT logic should live in <code>services/</code> not features/  </p>"},{"location":"chapter22/","title":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Chapter 22","text":""},{"location":"chapter22/#part-5-case-studies-and-templates","title":"Part 5: Case Studies and Templates","text":""},{"location":"chapter22/#22-complete-starter-templates","title":"22. Complete Starter Templates","text":"<p>\u201cTemplates aren't shortcuts. They're scaffolds for clarity.\u201d</p> <p>This chapter presents three real-world starter folder structures based on the philosophies and trade-offs explored throughout the book:</p> <ol> <li>Modular React + FastAPI Template</li> <li>Scalable React + FastAPI Template</li> <li>Hybrid AI Application Template (Modular features + Scalable backbone)</li> </ol> <p>Each template includes:</p> <ul> <li>\u2705 Folder layout</li> <li>\u2705 Key file responsibilities</li> <li>\u2705 CLI-ready structure (for cloning or bootstrapping)</li> <li>\u2705 Recommendations for growth</li> </ul>"},{"location":"chapter22/#modular-react-fastapi-template","title":"Modular React + FastAPI Template","text":"<p>For rapid prototyping and clean feature isolation</p>"},{"location":"chapter22/#root-structure","title":"Root Structure","text":"<pre><code>project-root/\n\u251c\u2500\u2500 backend/\n\u2502   \u2514\u2500\u2500 app/\n\u2502       \u2514\u2500\u2500 features/\n\u2502           \u251c\u2500\u2500 users/\n\u2502           \u2514\u2500\u2500 invoices/\n\u251c\u2500\u2500 frontend/\n\u2502   \u2514\u2500\u2500 src/\n\u2502       \u2514\u2500\u2500 features/\n\u2502           \u251c\u2500\u2500 users/\n\u2502           \u2514\u2500\u2500 invoices/\n\u251c\u2500\u2500 tests/\n\u2502   \u251c\u2500\u2500 users/\n\u2502   \u2514\u2500\u2500 invoices/\n</code></pre>"},{"location":"chapter22/#ideal-for","title":"Ideal For:","text":"<ul> <li>Small teams or solo devs</li> <li>Feature-driven apps</li> <li>Projects that may later scale</li> </ul>"},{"location":"chapter22/#growth-path","title":"Growth Path:","text":"<ul> <li>Move shared logic into <code>services/</code> as features multiply</li> <li>Extract common types to <code>shared/</code> or external packages</li> </ul>"},{"location":"chapter22/#scalable-react-fastapi-template","title":"Scalable React + FastAPI Template","text":"<p>For enterprise-grade apps or multi-team collaboration</p>"},{"location":"chapter22/#root-structure_1","title":"Root Structure","text":"<pre><code>project-root/\n\u251c\u2500\u2500 backend/\n\u2502   \u2514\u2500\u2500 app/\n\u2502       \u251c\u2500\u2500 api/\n\u2502       \u251c\u2500\u2500 services/\n\u2502       \u251c\u2500\u2500 schemas/\n\u2502       \u251c\u2500\u2500 core/\n\u2502       \u251c\u2500\u2500 vectorstore/\n\u2502       \u2514\u2500\u2500 workers/\n\u251c\u2500\u2500 frontend/\n\u2502   \u2514\u2500\u2500 src/\n\u2502       \u251c\u2500\u2500 features/\n\u2502       \u251c\u2500\u2500 components/\n\u2502       \u251c\u2500\u2500 services/\n\u2502       \u251c\u2500\u2500 hooks/\n\u2502       \u2514\u2500\u2500 shared/\n\u251c\u2500\u2500 tests/\n\u2502   \u251c\u2500\u2500 unit/\n\u2502   \u2514\u2500\u2500 integration/\n\u251c\u2500\u2500 .env, Dockerfile, docker-compose.yml\n</code></pre>"},{"location":"chapter22/#ideal-for_1","title":"Ideal For:","text":"<ul> <li>Teams &gt; 3 developers</li> <li>Microservices or LLM-powered systems</li> <li>RAG pipelines, background workers, CI/CD</li> </ul>"},{"location":"chapter22/#growth-path_1","title":"Growth Path:","text":"<ul> <li>Add <code>/jobs/</code> or <code>/tasks/</code> for scheduled jobs</li> <li>Implement <code>infra/</code> for IaC (e.g., Terraform, Pulumi)</li> </ul>"},{"location":"chapter22/#hybrid-ai-app-template-best-of-both-worlds","title":"Hybrid AI App Template (Best of Both Worlds)","text":"<p>Modular features + scalable service layers</p>"},{"location":"chapter22/#root-structure_2","title":"Root Structure","text":"<pre><code>project-root/\n\u251c\u2500\u2500 apps/\n\u2502   \u251c\u2500\u2500 frontend/\n\u2502   \u2514\u2500\u2500 backend/\n\u251c\u2500\u2500 packages/\n\u2502   \u2514\u2500\u2500 shared-schemas/\n\u251c\u2500\u2500 backend/\n\u2502   \u2514\u2500\u2500 app/\n\u2502       \u251c\u2500\u2500 features/\n\u2502       \u2502   \u251c\u2500\u2500 chatbot/\n\u2502       \u2502   \u2514\u2500\u2500 receipt/\n\u2502       \u251c\u2500\u2500 services/\n\u2502       \u251c\u2500\u2500 api/\n\u2502       \u251c\u2500\u2500 vectorstore/\n\u2502       \u2514\u2500\u2500 core/\n\u251c\u2500\u2500 frontend/\n\u2502   \u2514\u2500\u2500 src/\n\u2502       \u251c\u2500\u2500 features/\n\u2502       \u2502   \u251c\u2500\u2500 chatbot/\n\u2502       \u2502   \u2514\u2500\u2500 receipt/\n\u2502       \u251c\u2500\u2500 shared/\n\u2502       \u251c\u2500\u2500 hooks/\n\u2502       \u2514\u2500\u2500 components/\n\u251c\u2500\u2500 tests/\n\u2502   \u251c\u2500\u2500 chatbot/\n\u2502   \u2514\u2500\u2500 receipt/\n\u251c\u2500\u2500 Dockerfiles, CI/CD, .envs\n</code></pre>"},{"location":"chapter22/#ideal-for_2","title":"Ideal For:","text":"<ul> <li>AI apps with multiple pipelines (OCR + GPT + vector search)</li> <li>Shared embedding or file logic</li> <li>Production-ready Chatbots, Invoice Parsers, or Document RAG tools</li> </ul>"},{"location":"chapter22/#growth-path_2","title":"Growth Path:","text":"<ul> <li>Add monorepo tools: <code>nx</code>, <code>TurboRepo</code>, or <code>pnpm workspaces</code></li> <li>Use <code>shared-schemas/</code> or <code>shared-utils/</code> across frontend + backend</li> </ul>"},{"location":"chapter22/#bootstrapping-tips","title":"Bootstrapping Tips","text":"Task Tool Dev containers <code>.devcontainer/</code> + VSCode Remote Dockerized local dev <code>docker-compose.yml</code> with separate <code>frontend</code> and <code>backend</code> services Env management <code>.env</code> per app, <code>dotenv</code> in Python, Vite env vars in React Linting &amp; Formatting <code>black</code>, <code>ruff</code> (Python), <code>eslint</code>, <code>prettier</code> (JS) Monorepo support <code>pnpm workspaces</code> or <code>TurboRepo</code> Types &amp; validation sharing <code>zod</code> or <code>pydantic</code> in <code>shared-schemas</code>"},{"location":"chapter22/#github-repo-format-recommendation","title":"GitHub Repo Format Recommendation","text":"<p>Structure your repo like so:</p> <pre><code>ai-app-starter/\n\u251c\u2500\u2500 apps/\n\u2502   \u251c\u2500\u2500 frontend/\n\u2502   \u2514\u2500\u2500 backend/\n\u251c\u2500\u2500 packages/\n\u2502   \u251c\u2500\u2500 shared-schemas/\n\u2502   \u2514\u2500\u2500 shared-utils/\n\u251c\u2500\u2500 .github/\n\u2502   \u2514\u2500\u2500 workflows/\n\u2502       \u251c\u2500\u2500 test.yml\n\u2502       \u2514\u2500\u2500 deploy.yml\n\u251c\u2500\u2500 docker-compose.yml\n\u251c\u2500\u2500 README.md\n</code></pre>"},{"location":"chapter22/#final-advice","title":"Final Advice","text":"<ul> <li>Structure reflects team dynamics. Modular for individuals, scalable for squads.</li> <li>Structure is a trade-off map. No \u201cright\u201d answer, only intentional trade-offs.</li> <li>Structure is code philosophy. Enforce conventions that encode your values: reusability, clarity, testability.</li> </ul>"},{"location":"chapter3/","title":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Chapter 3","text":""},{"location":"chapter3/#part-1-foundations","title":"Part 1: Foundations","text":""},{"location":"chapter3/#3-modularity-vs-scalability","title":"3. Modularity vs. Scalability","text":"<p>Two buzzwords. One subtle, crucial difference.</p>"},{"location":"chapter3/#definitions-and-core-differences","title":"Definitions and Core Differences","text":"<p>In everyday conversation, modular and scalable are often used interchangeably. But in software architecture, they solve different problems.</p> <p>Let\u2019s break them down:</p> Concept What It Solves Key Metaphor Modularity Manageability of code LEGO blocks Scalability Growth under stress Load-bearing architecture <p>Modularity is about boundaries. It helps you keep logic isolated, composable, and understandable.</p> <p>Scalability is about layers. It helps you handle growth in codebase size, feature complexity, team size, or traffic\u2014without crumbling.</p> <p>Modularity is how well you can break things apart. Scalability is how well your system survives being pulled in every direction.</p>"},{"location":"chapter3/#why-most-projects-need-both","title":"Why Most Projects Need Both","text":"<p>Many projects start modular\u2014and stay that way too long.</p> <p>You may start with a clean, feature-based structure like:</p> <pre><code>src/\n\u251c\u2500\u2500 auth/\n\u251c\u2500\u2500 dashboard/\n\u251c\u2500\u2500 reports/\n</code></pre> <p>It feels great\u2014until:</p> <ul> <li>You add real-time WebSockets across features</li> <li>You integrate OpenAI or OCR that multiple features rely on</li> <li>You add roles and permissions</li> <li>You scale to 4 devs working in parallel</li> <li>You need versioned APIs</li> <li>You hit 50+ components</li> </ul> <p>Then the modular boundaries blur. You\u2019re forced to start thinking in layers, not just features.</p> <p>That\u2019s where scalability enters: A structure that supports not just clear separation but also growth, stability, and performance.</p>"},{"location":"chapter3/#the-core-trade-off-features-vs-layers","title":"The Core Trade-Off: Features vs. Layers","text":"<p>Let\u2019s compare how the two mindsets organize code:</p> Mindset Structure Focus Example Modular Group by feature <code>auth/</code>, <code>chatbot/</code>, <code>invoice/</code> Scalable Group by layer <code>api/</code>, <code>services/</code>, <code>schemas/</code>, <code>core/</code> <p>Modular structure answers:</p> <ul> <li>\u201cWhere does the chatbot upload logic live?\u201d</li> <li>\u201cCan I remove the invoice feature without affecting auth?\u201d</li> </ul> <p>Scalable structure answers:</p> <ul> <li>\u201cWhere do all external API integrations live?\u201d</li> <li>\u201cHow do I enforce request validation across the whole system?\u201d</li> <li>\u201cHow do we version our FastAPI routes cleanly?\u201d</li> </ul> <p>They\u2019re not enemies. They\u2019re two lenses for organizing complexity.</p>"},{"location":"chapter3/#a-real-example","title":"A Real Example","text":"<p>Imagine you\u2019re building a Document Intelligence Chatbot:</p> <ul> <li>You have <code>upload/</code>, <code>chat/</code>, and <code>settings/</code> as modules. (Modular)</li> <li> <p>But each one:</p> </li> <li> <p>Talks to a shared GPT service</p> </li> <li>Reads embeddings from a vector DB</li> <li>Logs activity for analytics</li> <li>Shares a token-based auth layer</li> </ul> <p>As the app evolves:</p> <ul> <li>You\u2019ll want <code>gpt_service.py</code>, <code>auth_utils.py</code>, <code>vectorstore.py</code>, and <code>logging_middleware.py</code>\u2014each in a consistent, layered location.</li> </ul> <p>That\u2019s when you introduce a scalable folder layout like:</p> <pre><code>backend/\n\u251c\u2500\u2500 api/\n\u251c\u2500\u2500 services/\n\u251c\u2500\u2500 schemas/\n\u251c\u2500\u2500 core/\n\u2514\u2500\u2500 infra/\n</code></pre> <p>And maybe even keep your original modular routes for clarity.</p> <p>This hybridization is common\u2014and powerful. But first, you must understand both ends of the spectrum.</p>"},{"location":"chapter3/#when-to-prioritize-one-over-the-other","title":"When to Prioritize One Over the Other","text":"Project Context Go Modular When... Go Scalable When... Solo MVP You want speed and feature-focused code Only if you plan to grow fast Small team (1\u20133) Clear feature ownership is key You expect cross-cutting services Growing app Isolation is becoming painful You need layers to decouple complexity Multi-team org Modularity keeps focus areas clean Scalability ensures code doesn\u2019t collide"},{"location":"chapter3/#think-in-features-and-layers","title":"Think in Features and Layers","text":"<p>The real world is not binary. You\u2019ll often start modular. Then realize you need scalability.</p> <p>The best engineers don\u2019t pick one\u2014they design for both.</p> <ul> <li>Use modular folders to group cohesive functionality.</li> <li>Use scalable layers to share logic, structure services, and support long-term growth.</li> </ul> <p>The rest of this book will show when and how to transition from one to the other\u2014and when to combine them.</p> <p>Next, we\u2019ll explore how folder structure affects real-world software quality\u2014including maintainability, testability, and refactoring.</p>"},{"location":"chapter4/","title":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Chapter 4","text":""},{"location":"chapter4/#part-1-foundations","title":"Part 1: Foundations","text":""},{"location":"chapter4/#4-how-structure-impacts-software-quality","title":"4. How Structure Impacts Software Quality","text":"<p>\u201cYour codebase is not just a machine. It\u2019s an ecosystem.\u201d</p>"},{"location":"chapter4/#structure-is-quality-not-cosmetics","title":"Structure Is Quality, Not Cosmetics","text":"<p>Folder structure is often dismissed as an aesthetic choice\u2014like naming files or choosing tabs over spaces.</p> <p>But in growing systems, structure becomes a force multiplier. It determines not just how readable your code is, but how your team behaves, how bugs are tracked, and how safely you can evolve a product.</p> <p>Let\u2019s break down the key dimensions of software quality impacted by folder structure:</p>"},{"location":"chapter4/#maintainability","title":"Maintainability","text":"<p>Can you understand, modify, and extend the code with confidence?</p> <p>A maintainable project has:</p> <ul> <li>Clear entry points per feature or layer</li> <li>Predictable folder naming and location conventions</li> <li>Minimal side effects between unrelated modules</li> <li>A strong signal-to-noise ratio: no hunting through junk folders</li> </ul> <p>Without structure:</p> <ul> <li>Logic leaks across files</li> <li>One bug fix causes another</li> <li>No one knows where to implement a new feature</li> <li>Junior devs hesitate to touch anything</li> </ul> <p>With structure:</p> <ul> <li>A new team member can trace the flow of a user action</li> <li>A bug in GPT parsing logic is isolated to one service</li> <li>Adding an OCR module doesn\u2019t break your vector DB loader</li> </ul> <p>Good folder structure creates boundaries\u2014and boundaries create safety.</p>"},{"location":"chapter4/#testability","title":"Testability","text":"<p>\u201cTestable code isn\u2019t magic\u2014it\u2019s structured.\u201d</p> <p>When folders follow clear ownership, writing and running tests becomes natural.</p> <p>Bad structure leads to:</p> <ul> <li>Tests hidden in obscure paths</li> <li>Shared logic that\u2019s hard to mock</li> <li>Feature logic tightly coupled to UI or DB</li> </ul> <p>Good structure enables:</p> <ul> <li>Unit tests per feature folder (e.g., <code>invoice/tests/</code>)</li> <li>Reusable test fixtures in <code>shared/test_helpers/</code></li> <li>Fast, isolated test runs without hitting live APIs</li> </ul> <p>Testing becomes not just possible, but predictable.</p> <p>Even better: structured tests reinforce the structure of the code itself\u2014making bad patterns stand out faster.</p>"},{"location":"chapter4/#developer-onboarding","title":"Developer Onboarding","text":"<p>\u201cIf you need to give someone a tour, you probably don\u2019t have a map.\u201d</p> <p>Folder structure is the first thing a new developer sees.</p> <p>In a strong codebase:</p> <ul> <li>It\u2019s obvious what each folder is responsible for</li> <li>The flow from API request \u2192 service logic \u2192 response \u2192 test is traceable</li> <li>There\u2019s a clean separation between core, features, and shared layers</li> </ul> <p>In a weak one:</p> <ul> <li>You open the project and stare at 20 top-level folders with cryptic names</li> <li>You can't tell what's business logic vs. utility vs. framework glue</li> </ul> <p>Great folder structure is like great UX\u2014it reduces friction, builds trust, and accelerates contribution.</p>"},{"location":"chapter4/#refactoring-ease","title":"Refactoring Ease","text":"<p>\u201cRefactoring is not rewriting\u2014it\u2019s reorganizing for clarity.\u201d</p> <p>You can\u2019t refactor what you can\u2019t isolate. And you can\u2019t isolate without structure.</p> <p>A good folder design gives you:</p> <ul> <li>Feature boundaries: safely remove <code>invoice/</code> without breaking <code>chatbot/</code></li> <li>Layered services: refactor GPT calls inside <code>services/gpt_service.py</code></li> <li>Clear surface areas: you know what each module exposes and depends on</li> </ul> <p>Structure also supports tools:</p> <ul> <li>Static analysis tools (e.g., <code>ruff</code>, <code>flake8</code>, <code>eslint</code>) benefit from structured scopes</li> <li>CI pipelines can test only the changed module\u2019s path</li> <li>Typed code and linters become more enforceable across modules</li> </ul> <p>The right structure makes refactoring surgical, not risky.</p>"},{"location":"chapter4/#developer-flow-and-mental-load","title":"Developer Flow and Mental Load","text":"<p>Let\u2019s get honest: most developers work in the flow. When the structure fights them, it breaks rhythm.</p> <p>A quality structure should:</p> <ul> <li>Let a dev know where to put code without asking</li> <li>Make exploration intuitive\u2014\"follow the file, follow the logic\"</li> <li>Minimize duplicate logic by centralizing shared helpers cleanly</li> <li>Surface tech debt through the structure itself</li> </ul> <p>Think of structure as the interface between developers and the codebase. It\u2019s a UI for the people writing software.</p> <p>And like any good UI\u2014it should guide behavior, reduce errors, and promote clarity.</p>"},{"location":"chapter4/#summary-structure-as-a-quality-lever","title":"Summary: Structure as a Quality Lever","text":"Quality Dimension With Bad Structure With Good Structure Maintainability Every change feels risky Each module feels owned and safe Testability Tests are fragile or missing Tests follow the structure of logic Onboarding New devs ask where everything is New devs ship within days Refactoring Breaking things is easy Refactoring is confident and surgical Team Flow Mental load increases Devs stay in flow longer <p>You don\u2019t need to chase perfection. You need to design for clarity. And that begins by aligning structure with architectural principles\u2014which is where we go next.</p>"},{"location":"chapter5/","title":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Chapter 5","text":""},{"location":"chapter5/#part-1-foundations","title":"Part 1: Foundations","text":""},{"location":"chapter5/#5-core-principles-of-architecture","title":"5. Core Principles of Architecture","text":"<p>Folder structure without principles is just rearranged chaos.</p>"},{"location":"chapter5/#why-principles-matter-first","title":"Why Principles Matter First","text":"<p>Before you argue over whether <code>components/</code> should live inside <code>features/</code> or alongside them\u2014step back.</p> <p>Folder structure isn\u2019t just about putting files in neat rows. It\u2019s about making architectural principles visible.</p> <p>Every good structure is guided by invisible laws. These laws define:</p> <ul> <li>How files are grouped</li> <li>How modules depend on each other</li> <li>Where logic lives\u2014and where it doesn\u2019t</li> <li>How flexible, testable, and scalable your app becomes</li> </ul> <p>Let\u2019s walk through the five foundational principles that underpin every high-quality folder structure.</p>"},{"location":"chapter5/#1-separation-of-concerns-soc","title":"1. Separation of Concerns (SoC)","text":"<p>\u201cOne folder. One responsibility.\u201d</p> <p>Every folder should represent a single concern: a page, a service, a business domain, or a shared utility.</p> <p>If a folder contains:</p> <ul> <li>API route handlers,</li> <li>UI components,</li> <li>GPT service logic,</li> <li>and database calls...</li> </ul> <p>\u2026it\u2019s no longer a folder\u2014it\u2019s a collision zone.</p> <p>SoC helps you answer:</p> <ul> <li>Where does rendering end and logic begin?</li> <li>Where do AI-specific utilities go?</li> <li>Where should I move this auth middleware so others can reuse it?</li> </ul> <p>Apply SoC at every level:</p> <ul> <li>File level: one purpose per file</li> <li>Folder level: one domain per folder</li> <li>App level: clear boundaries between frontend/backend/shared</li> </ul> <p>A well-separated structure gives you local reasoning: you don\u2019t have to understand the whole app to fix one part.</p>"},{"location":"chapter5/#2-high-cohesion-low-coupling","title":"2. \ud83e\uddf1 High Cohesion, Low Coupling","text":"<p>\u201cCohesion groups what belongs together. Coupling tears apart what should stay apart.\u201d</p> <p>High Cohesion means:</p> <ul> <li>Related files live together</li> <li>A module\u2019s logic and tests are close</li> <li>Changes happen in one place</li> </ul> <p>Low Coupling means:</p> <ul> <li>Modules know as little as possible about each other</li> <li>Shared logic is exposed via clear interfaces</li> <li>Breaking changes are contained within their boundaries</li> </ul> <p>Example:</p> <pre><code>chatbot/\n\u251c\u2500\u2500 api/\n\u251c\u2500\u2500 services/\n\u251c\u2500\u2500 components/\n</code></pre> <p>All chatbot-specific logic is cohesive. But if chatbot\u2019s code directly calls <code>invoice/ocr_utils.py</code>\u2014that\u2019s tight coupling. Instead, shared OCR logic should live in a neutral layer like <code>shared/ocr/</code>.</p> <p>Cohesion makes modules strong. Decoupling makes systems resilient.</p>"},{"location":"chapter5/#3-dry-and-reusability","title":"3. DRY and Reusability","text":"<p>\u201cDon\u2019t Repeat Yourself\u2014unless it makes things clearer.\u201d</p> <p>DRY isn't about obsessively deduplicating lines of code. It\u2019s about eliminating accidental repetition\u2014the kind that creates bugs and bloated deployments.</p> <p>Folder structure supports DRY when:</p> <ul> <li>Shared hooks and services are isolated in <code>shared/</code> or <code>core/</code></li> <li>Feature code doesn\u2019t reinvent the wheel because it can find the wheel</li> <li>GPT-related logic lives in one <code>gpt_service.py</code>, not five copied files</li> </ul> <p>That said, be careful: premature sharing leads to unwanted coupling. If two features need similar but divergent behavior, copy first. Only extract shared code once the pattern emerges.</p> <p>Reusability works best when structure makes reuse obvious.</p>"},{"location":"chapter5/#4-convention-over-configuration","title":"4. Convention over Configuration","text":"<p>\u201cStructure isn\u2019t just for machines. It\u2019s for humans.\u201d</p> <p>A strong folder layout reduces the need for explanations.</p> <p>Good conventions answer questions like:</p> <ul> <li>Where do I find the services for <code>invoice/</code>?</li> <li>Where should new routes go?</li> <li>Where are the frontend hooks stored?</li> <li>What\u2019s the standard file name for a test or schema?</li> </ul> <p>Examples:</p> <ul> <li><code>api/</code> always holds routes.</li> <li><code>services/</code> always handles external integrations and business logic.</li> <li><code>__tests__/</code> lives alongside the module it tests.</li> </ul> <p>These conventions become muscle memory. They create a shared mental model that reduces onboarding time, avoids misplacement, and prevents structural drift.</p> <p>Choose conventions early. Then stick to them.</p>"},{"location":"chapter5/#5-structure-as-api-for-teams","title":"5. Structure as API for Teams","text":"<p>\u201cIf your codebase is a city, folders are the zoning laws.\u201d</p> <p>Structure isn\u2019t just technical. It\u2019s social.</p> <p>Each team, each developer, each contributor relies on structure to:</p> <ul> <li>Understand boundaries</li> <li>Avoid stepping on others' work</li> <li>Know what they own and what they don\u2019t</li> <li>Merge code with confidence</li> </ul> <p>Great folder structures:</p> <ul> <li>Create lanes for frontend vs backend teams</li> <li>Prevent merge conflicts by minimizing overlap</li> <li>Enable component reuse without cross-team negotiation</li> </ul> <p>When structure reflects architecture\u2014and architecture reflects ownership\u2014teams move faster, with fewer surprises.</p> <p>Structure is a communication tool. Make it speak clearly.</p>"},{"location":"chapter5/#the-principles-in-practice","title":"The Principles in Practice","text":"Principle In Practice Example Separation of Concerns <code>chatbot/api/</code>, <code>chatbot/services/</code>, <code>chatbot/ui/</code> High Cohesion, Low Coupling <code>gpt_service.py</code> reused across modules via DI container DRY &amp; Reusability <code>shared/hooks/useFileUpload.ts</code>, not duplicated in features Convention &gt; Configuration All test files end in <code>.test.ts</code> and live beside logic Structure as Team API Clearly isolated folders per team or domain"},{"location":"chapter6/","title":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Chapter 6","text":""},{"location":"chapter6/#part-1-foundations","title":"Part 1: Foundations","text":""},{"location":"chapter6/#6-understanding-the-stack","title":"6. Understanding the Stack","text":"<p>\u201cStructure isn\u2019t built in a vacuum. It reflects your stack\u2019s behavior.\u201d</p>"},{"location":"chapter6/#why-stack-awareness-matters","title":"Why Stack Awareness Matters","text":"<p>Your folder structure should mirror how your app works\u2014not fight it.</p> <p>You can\u2019t structure a React + FastAPI app the same way you would structure a monolithic Rails app or a serverless function chain. The communication style, state boundaries, and build process between frontend and backend shape how your code should be organized.</p> <p>This chapter gives you a bird\u2019s-eye view of the React + FastAPI full-stack architecture\u2014so you know what you\u2019re structuring and why certain patterns emerge.</p> <p>Let\u2019s break it down.</p>"},{"location":"chapter6/#react-vite-the-frontend","title":"React + Vite: The Frontend","text":"<p>React is a component-driven UI library. Vite is its next-gen build tool, optimized for speed and modularity.</p>"},{"location":"chapter6/#key-characteristics","title":"Key Characteristics:","text":"<ul> <li>File-based routing (via React Router, not enforced by framework)</li> <li>Component reusability is encouraged (hooks, context, UI libraries)</li> <li>Client-side rendering by default</li> <li>Modular JavaScript/TypeScript imports</li> <li>Single-page application model, often talking to an API backend</li> <li>Optional integrations: state management (Zustand, Redux, Jotai), form libs, TailwindCSS, etc.</li> </ul>"},{"location":"chapter6/#frontend-folder-design-considerations","title":"Frontend Folder Design Considerations:","text":"<ul> <li> <p>You\u2019ll likely need folders for:</p> </li> <li> <p><code>components/</code>: shared visual components</p> </li> <li><code>features/</code>: domain-based modules (e.g., chatbot, invoice)</li> <li><code>hooks/</code>: reusable logic</li> <li><code>api/</code>: backend interaction (e.g., axios or fetch wrappers)</li> <li><code>assets/</code>: static images, videos, icons</li> <li><code>routes/</code>: layout-level control (React Router v6)</li> <li><code>context/</code> or <code>store/</code>: global or scoped state</li> </ul>"},{"location":"chapter6/#common-patterns","title":"Common Patterns:","text":"<ul> <li>Feature-first foldering is often better early on</li> <li>Shared logic moves into <code>shared/</code> or <code>lib/</code> as complexity grows</li> <li>Components are often colocated with CSS or styled using utility-first approaches (e.g., Tailwind)</li> </ul>"},{"location":"chapter6/#fastapi-the-backend","title":"FastAPI: The Backend","text":"<p>FastAPI is a modern Python web framework built on Pydantic and Starlette. It\u2019s API-first, type-hinted, and async-ready.</p>"},{"location":"chapter6/#key-characteristics_1","title":"Key Characteristics:","text":"<ul> <li>Route-first design: APIs are defined via decorators (<code>@router.get</code>, <code>@router.post</code>)</li> <li>Request validation and serialization via Pydantic schemas</li> <li>ASGI-native: supports WebSockets, streaming, background tasks</li> <li>Auto-docs via OpenAPI, great for teams and testing</li> <li>Flexible architecture: microservice-ready, but can be modular or monolithic</li> </ul>"},{"location":"chapter6/#backend-folder-design-considerations","title":"Backend Folder Design Considerations:","text":"<ul> <li> <p>Key layers include:</p> </li> <li> <p><code>api/</code>: all route logic</p> </li> <li><code>schemas/</code>: request/response Pydantic models</li> <li><code>services/</code>: business logic</li> <li><code>core/</code>: config, constants, middleware</li> <li><code>infra/</code>: database, vector DBs, storage clients</li> <li><code>utils/</code> or <code>shared/</code>: generic reusable helpers</li> <li><code>tests/</code>: unit + integration test structure</li> </ul>"},{"location":"chapter6/#common-patterns_1","title":"Common Patterns:","text":"<ul> <li>Layer-first is preferred for complex or team-sized projects</li> <li>Dependency injection (via <code>Depends</code>) supports testability</li> <li>Router composition (e.g., <code>include_router()</code>) allows per-module routing logic</li> <li>Can be modularized per feature or layered\u2014or both (hybrid)</li> </ul>"},{"location":"chapter6/#how-react-and-fastapi-communicate","title":"How React and FastAPI Communicate","text":"<p>The two parts of your stack are decoupled\u2014but tightly integrated.</p> Communication Layer Tech Structure Tip REST API JSON over HTTP Use an <code>api/</code> folder on both frontend and backend WebSockets Real-time, duplex Isolate WS logic in a shared <code>sockets/</code> or <code>events/</code> layer Streaming <code>yield</code> from backend \u2192 chunks in frontend Group stream handlers and frontend consumers as a unit File Uploads <code>multipart/form-data</code> Create a unified <code>upload/</code> or <code>documents/</code> module Authentication JWT, OAuth, sessions Mirror <code>auth/</code> logic in both frontend and backend features Embeddings/Vector Search Supabase, Pinecone, Weaviate Treat as an infrastructure concern in <code>infra/</code> or <code>services/</code>"},{"location":"chapter6/#shared-challenges-in-a-full-stack-ai-app","title":"Shared Challenges in a Full-Stack AI App","text":"<p>With React + FastAPI, especially in AI-centric use cases (e.g., OCR, GPT, chatbots), you face shared architectural challenges that should influence folder design:</p>"},{"location":"chapter6/#1-state-synchronization","title":"1. State Synchronization","text":"<ul> <li>React stores client-side UI state, auth state, and sometimes cached data</li> <li>Backend stores ground truth (e.g., user sessions, file uploads, GPT responses)</li> <li>Solution: use <code>context/</code> or <code>store/</code> in React + strict separation of <code>services/</code> and <code>api/</code> in FastAPI</li> </ul>"},{"location":"chapter6/#2-api-versioning","title":"2. API Versioning","text":"<ul> <li>As your API grows, changes must be non-breaking</li> <li>Solution: versioned routers (e.g., <code>api/v1/chat.py</code>, <code>api/v2/chat.py</code>) and API clients on frontend</li> </ul>"},{"location":"chapter6/#3-authentication-authorization","title":"3. Authentication &amp; Authorization","text":"<ul> <li>Frontend handles token storage (often via HTTP-only cookies or <code>localStorage</code>)</li> <li>Backend must validate tokens on each request</li> <li>Solution: <code>auth/</code> folders in both front and back, shared schema if monorepo</li> </ul>"},{"location":"chapter6/#4-model-wrapping-and-latency","title":"4. Model Wrapping and Latency","text":"<ul> <li>GPT calls, vector DB lookups, or OCR take time</li> <li>Use background jobs (<code>BackgroundTasks</code>, Celery) and streaming where appropriate</li> </ul>"},{"location":"chapter6/#5-error-handling-and-logging","title":"5. Error Handling and Logging","text":"<ul> <li>Frontend: user-friendly messages, fallback states</li> <li>Backend: structured logs, <code>try/except</code> middleware, Sentry integration</li> </ul>"},{"location":"chapter6/#summary-structure-reflects-stack-realities","title":"Summary: Structure Reflects Stack Realities","text":"Layer React (Vite) FastAPI Presentation <code>components/</code>, <code>routes/</code> N/A (or static templates) State <code>context/</code>, <code>store/</code>, <code>hooks/</code> <code>Depends()</code>, middleware, DB API Integration <code>api/</code>, <code>services/</code> <code>api/</code>, <code>schemas/</code>, <code>services/</code> Business Logic <code>features/</code>, <code>services/</code> <code>services/</code>, <code>core/</code>, <code>infra/</code> Shared Logic <code>shared/</code>, <code>lib/</code> <code>shared/</code>, <code>utils/</code> Tests <code>__tests__/</code>, colocated with features <code>tests/</code>, per module or per layer <p>A well-structured project doesn\u2019t just separate concerns\u2014it reflects the shape of your stack.</p>"},{"location":"chapter7/","title":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Chapter 7","text":""},{"location":"chapter7/#part-2-modularity","title":"Part 2: Modularity","text":""},{"location":"chapter7/#7-modular-architecture-overview","title":"7. Modular Architecture Overview","text":"<p>\u201cWhen features are independent, everything moves faster.\u201d</p>"},{"location":"chapter7/#what-is-modular-architecture","title":"What Is Modular Architecture?","text":"<p>Modular architecture means structuring your application into self-contained, feature-focused units. Each module is responsible for its own UI, business logic, API interaction, and sometimes even its own tests and styles.</p> <p>In simple terms:</p> <p>A module owns everything it needs\u2014and nothing more.</p> <p>Instead of organizing by function (e.g., all components in one folder, all hooks in another), we organize by feature (e.g., <code>auth/</code>, <code>chatbot/</code>, <code>invoice/</code>).</p> <p>Each module:</p> <ul> <li>Has clear boundaries</li> <li>Is testable in isolation</li> <li>Can evolve without affecting others</li> <li>Feels like a mini-app within a larger ecosystem</li> </ul> <p>This isn't about silos. It\u2019s about decoupling by design.</p>"},{"location":"chapter7/#when-to-use-modular-structure","title":"When to Use Modular Structure","text":"<p>You don\u2019t need microservices to think modularly. You just need growing complexity.</p> <p>Use modular structure when:</p> <ul> <li>You\u2019re building an app with multiple distinct features</li> <li>You want to scale development across features or teams</li> <li>You need clean ownership boundaries for onboarding or debugging</li> <li>You plan to refactor parts of the app independently</li> </ul> <p>It\u2019s especially effective in:</p> <ul> <li>AI-first apps (e.g., chat + OCR + upload + settings are all modularizable)</li> <li>SaaS dashboards with multiple feature sets</li> <li>Internal tools with fast-moving specs and MVP-to-prod transitions</li> </ul>"},{"location":"chapter7/#modularity-vs-flat-structure","title":"Modularity vs. Flat Structure","text":"<p>Let\u2019s compare:</p> Flat Structure (by Type) Modular Structure (by Feature) <code>components/</code>, <code>hooks/</code>, <code>api/</code>, <code>services/</code> <code>chatbot/</code>, <code>invoice/</code>, <code>auth/</code> Everything of the same kind in one folder Everything related to one feature in one folder Good for tiny apps Better for evolving apps Encourages reuse early Encourages independence first Easy to outgrow Easy to extend <p>Flat structures feel simple\u2014until they grow. Modular structures feel heavier\u2014until they scale.</p>"},{"location":"chapter7/#benefits-of-modularity","title":"Benefits of Modularity","text":"<p>Let\u2019s get specific. Here\u2019s what modularity unlocks:</p>"},{"location":"chapter7/#isolation-of-logic","title":"\u2705 Isolation of Logic","text":"<p>Each module owns its flow. That means fewer cross-feature bugs, easier hotfixes, and faster shipping.</p>"},{"location":"chapter7/#faster-feature-development","title":"\u2705 Faster Feature Development","text":"<p>Dev A works on <code>invoice/</code>, Dev B on <code>chatbot/</code>\u2014no collisions. They deploy safely and in parallel.</p>"},{"location":"chapter7/#localized-testing","title":"\u2705 Localized Testing","text":"<p>Tests live next to the logic they test. Each feature can be tested, mocked, and even deployed (in some cases) independently.</p>"},{"location":"chapter7/#easier-refactoring","title":"\u2705 Easier Refactoring","text":"<p>Need to replace GPT with Claude or add Pinecone? Update only <code>chatbot/services/llm.py</code>\u2014no side effects.</p>"},{"location":"chapter7/#cognitive-simplicity","title":"\u2705 Cognitive Simplicity","text":"<p>When you open <code>auth/</code>, you know it\u2019s just about auth. No need to trace logic scattered across multiple global folders.</p>"},{"location":"chapter7/#trade-offs-and-limitations","title":"Trade-offs and Limitations","text":"<p>No pattern is perfect. Modularity also introduces friction.</p> Trade-off Description Shared Logic Duplication You may need to extract common code carefully (e.g., <code>gpt_service.py</code> or <code>ocr_utils.py</code>) Naming Collisions Each module might have a <code>services/</code>, <code>api/</code>, <code>hooks/</code>, etc.\u2014you need clear structure and IDE support Deep Nesting If unstructured, you end up with too many nested folders Refactor Complexity Moving from modular \u2192 scalable (layered) requires care and planning <p>You\u2019ll learn how to solve these in later chapters (especially Part 4).</p>"},{"location":"chapter7/#a-preview-of-modular-structure","title":"A Preview of Modular Structure","text":"<p>Example modular folder setup for a React + FastAPI project:</p> <pre><code>frontend/\n\u2514\u2500\u2500 src/\n    \u251c\u2500\u2500 chatbot/\n    \u2502   \u251c\u2500\u2500 components/\n    \u2502   \u251c\u2500\u2500 hooks/\n    \u2502   \u251c\u2500\u2500 api/\n    \u2502   \u2514\u2500\u2500 styles/\n    \u251c\u2500\u2500 invoice/\n    \u2502   \u251c\u2500\u2500 components/\n    \u2502   \u251c\u2500\u2500 services/\n    \u2502   \u2514\u2500\u2500 tests/\n    \u2514\u2500\u2500 shared/\n        \u251c\u2500\u2500 ui/\n        \u251c\u2500\u2500 hooks/\n        \u2514\u2500\u2500 constants/\n</code></pre> <pre><code>backend/\n\u2514\u2500\u2500 app/\n    \u251c\u2500\u2500 chatbot/\n    \u2502   \u251c\u2500\u2500 api/\n    \u2502   \u251c\u2500\u2500 services/\n    \u2502   \u2514\u2500\u2500 schemas/\n    \u251c\u2500\u2500 invoice/\n    \u2502   \u251c\u2500\u2500 api/\n    \u2502   \u251c\u2500\u2500 gpt_parser.py\n    \u2502   \u2514\u2500\u2500 tests/\n    \u251c\u2500\u2500 shared/\n    \u2502   \u251c\u2500\u2500 ocr/\n    \u2502   \u251c\u2500\u2500 gpt/\n    \u2502   \u2514\u2500\u2500 auth/\n    \u2514\u2500\u2500 main.py\n</code></pre> <p>Each feature is self-contained, and shared logic is lifted into <code>shared/</code>.</p>"},{"location":"chapter7/#real-world-modularity-in-practice","title":"Real-World Modularity in Practice","text":"<p>In upcoming chapters, we\u2019ll break this down into:</p> <ul> <li>Frontend modularization with React + Vite (Chapter 8)</li> <li>Backend modularization with FastAPI (Chapter 9)</li> <li>Modular testing patterns for both (Chapter 10)</li> </ul> <p>By the end of Part 2, you\u2019ll have a full blueprint for building a clean, modular app with:</p> <ul> <li>Fast onboarding</li> <li>Clear feature ownership</li> <li>Minimal surprises across teams</li> </ul> <p>Modularity is how structure starts.</p>"},{"location":"chapter8/","title":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Chapter 8","text":""},{"location":"chapter8/#part-2-modularity","title":"Part 2: Modularity","text":""},{"location":"chapter8/#8-modular-folder-structure-for-react-vite","title":"8. Modular Folder Structure for React + Vite","text":"<p>\u201cFeatures first. Everything else follows.\u201d</p>"},{"location":"chapter8/#why-feature-first-wins","title":"Why Feature-First Wins","text":"<p>React encourages composability\u2014building UI from reusable components. But without the right structure, composability becomes clutter.</p> <p>The most scalable pattern in growing React apps is a feature-first folder structure, where each module owns its:</p> <ul> <li>Components</li> <li>Hooks</li> <li>API logic</li> <li>Styles</li> <li>Tests</li> <li>Local state (if applicable)</li> </ul> <p>Instead of separating code by type, we separate by purpose.</p> <p>You don\u2019t have a <code>components/</code> folder. You have a <code>chatbot/components/</code> folder. You don\u2019t write <code>useUpload.ts</code>. You write <code>upload/hooks/useFileUpload.ts</code>.</p> <p>This allows developers to reason locally, test quickly, and refactor confidently.</p>"},{"location":"chapter8/#example-modular-folder-layout-react-vite","title":"Example Modular Folder Layout (React + Vite)","text":"<p>Let\u2019s look at a common structure:</p> <pre><code>src/\n\u251c\u2500\u2500 chatbot/\n\u2502   \u251c\u2500\u2500 components/\n\u2502   \u251c\u2500\u2500 hooks/\n\u2502   \u251c\u2500\u2500 api/\n\u2502   \u251c\u2500\u2500 services/\n\u2502   \u251c\u2500\u2500 styles/\n\u2502   \u2514\u2500\u2500 __tests__/\n\u251c\u2500\u2500 invoice/\n\u2502   \u251c\u2500\u2500 components/\n\u2502   \u251c\u2500\u2500 services/\n\u2502   \u251c\u2500\u2500 utils/\n\u2502   \u2514\u2500\u2500 __tests__/\n\u251c\u2500\u2500 upload/\n\u2502   \u251c\u2500\u2500 components/\n\u2502   \u251c\u2500\u2500 hooks/\n\u2502   \u2514\u2500\u2500 api/\n\u251c\u2500\u2500 shared/\n\u2502   \u251c\u2500\u2500 components/\n\u2502   \u251c\u2500\u2500 hooks/\n\u2502   \u251c\u2500\u2500 ui/\n\u2502   \u251c\u2500\u2500 constants/\n\u2502   \u2514\u2500\u2500 types/\n\u251c\u2500\u2500 routes/\n\u2502   \u2514\u2500\u2500 index.tsx\n\u2514\u2500\u2500 main.tsx\n</code></pre> <p>Each feature (e.g., <code>chatbot/</code>, <code>invoice/</code>, <code>upload/</code>) owns its own internal structure. The <code>shared/</code> folder holds reusable utilities, types, UI primitives, and global assets.</p>"},{"location":"chapter8/#breaking-it-down-folder-by-folder","title":"Breaking It Down: Folder by Folder","text":""},{"location":"chapter8/#-chatbot-invoice-upload-feature-modules","title":"- <code>chatbot/</code>, <code>invoice/</code>, <code>upload/</code> (Feature Modules)","text":"<p>Each folder represents a domain of functionality. Internally, it may contain:</p> Subfolder Purpose <code>components/</code> React components scoped to the feature <code>hooks/</code> Feature-specific logic (e.g., <code>useChatbotInput</code>) <code>api/</code> Feature-specific API calls <code>services/</code> Feature-specific logic or wrappers <code>styles/</code> Scoped CSS modules or Tailwind config extensions <code>__tests__/</code> Unit and integration tests <p>These folders evolve independently. You can rewrite <code>invoice/</code> logic without touching <code>chatbot/</code>.</p>"},{"location":"chapter8/#-shared","title":"- <code>shared/</code>","text":"<p>This is your common ground\u2014used by all features but owned by none.</p> <p>Recommended structure:</p> <pre><code>shared/\n\u251c\u2500\u2500 components/      # Globally reused components (e.g., Button, Modal)\n\u251c\u2500\u2500 hooks/           # Truly shared hooks (e.g., useDebounce, useClipboard)\n\u251c\u2500\u2500 ui/              # Design tokens, themes, Tailwind config, icons\n\u251c\u2500\u2500 types/           # Global TypeScript types and interfaces\n\u251c\u2500\u2500 utils/           # Shared utility functions (e.g., dateFormat)\n\u251c\u2500\u2500 constants/       # Global constants and enums\n</code></pre> <p>Think of <code>shared/</code> as your design system + logic toolbox.</p>"},{"location":"chapter8/#-routes","title":"- <code>routes/</code>","text":"<p>This is where React Router v6 lives. You define your top-level routes here and import feature pages as lazy-loaded modules.</p> <p>Example:</p> <pre><code>import { ChatbotPage } from '@/chatbot';\nimport { InvoicePage } from '@/invoice';\n\nconst routes = [\n  { path: '/chatbot', element: &lt;ChatbotPage /&gt; },\n  { path: '/invoice', element: &lt;InvoicePage /&gt; },\n];\n</code></pre> <p>You can also colocate layouts here (<code>MainLayout.tsx</code>, <code>DashboardLayout.tsx</code>).</p>"},{"location":"chapter8/#managing-component-isolation","title":"Managing Component Isolation","text":"<p>One key to good modularity is component scope. Not all components are meant to be reused across the app.</p> Component Type Folder Location Feature-specific UI <code>invoice/components/InvoiceRow.tsx</code> Globally reused UI <code>shared/components/Tooltip.tsx</code> Third-party wrappers <code>shared/ui/CustomModal.tsx</code> <p>A rule of thumb:</p> <p>If only one feature uses it, keep it in the feature. If two or more features need it, move it to <code>shared/</code>.</p>"},{"location":"chapter8/#organizing-hooks-services-and-utils-within-modules","title":"Organizing Hooks, Services, and Utils Within Modules","text":"<p>Let\u2019s say the <code>chatbot/</code> feature handles:</p> <ul> <li>Input parsing</li> <li>GPT API calls</li> <li>Response rendering</li> </ul> <p>You might structure like this:</p> <pre><code>chatbot/\n\u251c\u2500\u2500 hooks/\n\u2502   \u2514\u2500\u2500 useStreamingChat.ts\n\u251c\u2500\u2500 services/\n\u2502   \u2514\u2500\u2500 gptService.ts\n\u251c\u2500\u2500 api/\n\u2502   \u2514\u2500\u2500 postMessage.ts\n\u251c\u2500\u2500 components/\n\u2502   \u251c\u2500\u2500 ChatInput.tsx\n\u2502   \u2514\u2500\u2500 MessageList.tsx\n</code></pre> <p>You avoid shared state bleed by:</p> <ul> <li>Keeping logic in <code>hooks/</code> instead of dumping it into components</li> <li>Wrapping API calls in <code>api/</code>, not <code>components/</code></li> <li>Using <code>context/</code> if you need local state across deeply nested components</li> </ul> <p>Each module becomes predictable and testable.</p>"},{"location":"chapter8/#naming-conventions-for-modular-files","title":"Naming Conventions for Modular Files","text":"<p>Consistency matters\u2014especially as you scale. Here are suggestions:</p> Pattern Example Hook prefix <code>useChatSession.ts</code> Test suffix <code>ChatInput.test.tsx</code> Service suffix <code>gptService.ts</code> Component file = component name <code>ChatInput.tsx</code> API files as verbs <code>postMessage.ts</code>, <code>getConversations.ts</code> <p>Avoid vague names like <code>utils.ts</code>, <code>index.ts</code>, or <code>helpers.ts</code> unless scoped with clear purpose.</p>"},{"location":"chapter8/#keeping-tests-close-to-features","title":"Keeping Tests Close to Features","text":"<p>React modular structure benefits from co-located testing:</p> <ul> <li>Put <code>__tests__/</code> inside each feature folder</li> <li>Use <code>jest</code>, <code>vitest</code>, or <code>playwright</code> with file pattern targeting</li> <li>Name tests after their targets (e.g., <code>ChatInput.test.tsx</code>)</li> </ul> <p>This gives you:</p> <ul> <li>Fast local iteration</li> <li>Easy mocking of feature-local services</li> <li>Clean CI targeting: test only changed modules</li> </ul>"},{"location":"chapter8/#avoiding-shared-state-bleed","title":"Avoiding Shared State Bleed","text":"<p>One common pitfall in modular React apps: global state leakage.</p> <p>Symptoms:</p> <ul> <li>Features accidentally rely on global context</li> <li>Changes in one feature affect others</li> <li>Debugging becomes non-local</li> </ul> <p>Solutions:</p> <ul> <li>Prefer feature-local state via hooks and <code>useReducer</code></li> <li>Use React Context only for true cross-feature concerns (e.g., user session)</li> <li>Use state managers like Zustand or Jotai to keep scoped atoms</li> </ul> <p>Structure should make boundaries explicit.</p>"},{"location":"chapter8/#summary-react-modularity-best-practices","title":"Summary: React Modularity Best Practices","text":"Principle Practice Feature-first Create folders per domain (<code>chatbot/</code>, <code>invoice/</code>) Component isolation Only share what\u2019s reused Localize logic Use <code>hooks/</code>, <code>services/</code>, <code>api/</code> per feature Co-locate tests <code>__tests__/</code> live beside logic Share intentionally Extract to <code>shared/</code> only when duplication becomes real <p>Modular React apps scale better not just in code\u2014but in team velocity.</p> <p>Next: we apply the same mindset to the backend side with FastAPI\u2014where modular services, schemas, and routes need their own design principles.</p>"},{"location":"chapter9/","title":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Chapter 9","text":""},{"location":"chapter9/#part-2-modularity","title":"Part 2: Modularity","text":""},{"location":"chapter9/#9-modular-folder-structure-for-fastapi","title":"9. Modular Folder Structure for FastAPI","text":"<p>\u201cFastAPI is flexible enough to let you do anything. But structure tells you what you should do.\u201d</p>"},{"location":"chapter9/#why-modularity-matters-more-in-backend","title":"Why Modularity Matters More in Backend","text":"<p>In a React frontend, the biggest risks of poor structure are visual bugs, state bleed, or duplicated logic.</p> <p>In a FastAPI backend, bad structure means:</p> <ul> <li>Route spaghetti</li> <li>Logic leakage</li> <li>Circular imports</li> <li>Untestable services</li> <li>Monolithic pain</li> </ul> <p>Modular folder design in FastAPI creates cleanly separated APIs, testable service layers, and an architecture that evolves with your app.</p> <p>This chapter walks you through how to build modular backends that scale\u2014with clear folders, sharp imports, and minimal surprise.</p>"},{"location":"chapter9/#what-feature-centric-means-in-fastapi","title":"What \u201cFeature-Centric\u201d Means in FastAPI","text":"<p>Just like the frontend, modular FastAPI apps group logic by feature, not just by file type.</p> <p>Instead of:</p> <pre><code>app/\n\u251c\u2500\u2500 api/\n\u251c\u2500\u2500 services/\n\u251c\u2500\u2500 schemas/\n</code></pre> <p>You build:</p> <pre><code>app/\n\u251c\u2500\u2500 chatbot/\n\u2502   \u251c\u2500\u2500 api/\n\u2502   \u251c\u2500\u2500 services/\n\u2502   \u251c\u2500\u2500 schemas/\n\u251c\u2500\u2500 invoice/\n\u2502   \u251c\u2500\u2500 api/\n\u2502   \u251c\u2500\u2500 gpt_parser.py\n\u2502   \u2514\u2500\u2500 schemas/\n\u251c\u2500\u2500 shared/\n\u2502   \u251c\u2500\u2500 ocr/\n\u2502   \u251c\u2500\u2500 gpt/\n\u2502   \u2514\u2500\u2500 db/\n</code></pre> <p>Each feature module owns its API, logic, and schemas.</p> <p>You gain:</p> <ul> <li>Isolation for debugging</li> <li>Parallel development</li> <li>Feature-based ownership</li> </ul>"},{"location":"chapter9/#example-modular-fastapi-folder-layout","title":"Example Modular FastAPI Folder Layout","text":"<pre><code>app/\n\u251c\u2500\u2500 chatbot/\n\u2502   \u251c\u2500\u2500 api/               # Routes (chatbot endpoints)\n\u2502   \u251c\u2500\u2500 services/          # Business logic (streaming, tokenization)\n\u2502   \u251c\u2500\u2500 schemas/           # Request/response models\n\u2502   \u251c\u2500\u2500 utils/             # Optional: local GPT wrappers, guards\n\u2502   \u2514\u2500\u2500 __tests__/         # Feature-scoped unit tests\n\u251c\u2500\u2500 invoice/\n\u2502   \u251c\u2500\u2500 api/\n\u2502   \u251c\u2500\u2500 services/\n\u2502   \u251c\u2500\u2500 schemas/\n\u2502   \u2514\u2500\u2500 __tests__/\n\u251c\u2500\u2500 shared/\n\u2502   \u251c\u2500\u2500 gpt/               # GPT/OpenAI clients\n\u2502   \u251c\u2500\u2500 ocr/               # pytesseract, EasyOCR, image preprocessing\n\u2502   \u251c\u2500\u2500 db/                # DB engine, models, repositories\n\u2502   \u251c\u2500\u2500 auth/              # JWT validation, role guard utils\n\u2502   \u2514\u2500\u2500 test_helpers/      # Mock clients, test fixtures\n\u251c\u2500\u2500 core/                  # Global settings, constants, DI container\n\u251c\u2500\u2500 main.py                # FastAPI app entry point\n\u2514\u2500\u2500 routers.py             # Route inclusion and router setup\n</code></pre>"},{"location":"chapter9/#how-to-organize-routes-schemas-and-services","title":"How to Organize Routes, Schemas, and Services","text":""},{"location":"chapter9/#routes-api","title":"Routes \u2192 <code>/api/</code>","text":"<p>Every feature should define its own routes in a dedicated file (or files) under <code>api/</code>.</p> <pre><code># chatbot/api/chat_routes.py\nfrom fastapi import APIRouter\nfrom ..services.chat_service import stream_response\n\nrouter = APIRouter()\n\n@router.post(\"/chat\")\nasync def chat_handler(payload: ChatRequest):\n    return await stream_response(payload)\n</code></pre> <p>Then in <code>routers.py</code> (or <code>main.py</code>):</p> <pre><code>from chatbot.api import chat_routes\nfrom invoice.api import invoice_routes\n\napp.include_router(chat_routes.router, prefix=\"/chatbot\")\napp.include_router(invoice_routes.router, prefix=\"/invoice\")\n</code></pre> <p>This modularizes routing logic without polluting <code>main.py</code>.</p>"},{"location":"chapter9/#schemas-schemas","title":"Schemas \u2192 <code>/schemas/</code>","text":"<p>Pydantic models for request/response validation should be:</p> <ul> <li>Inside each feature</li> <li>Named clearly (e.g., <code>ChatRequest</code>, <code>InvoiceUploadRequest</code>)</li> <li>Not shared unless 100% generic</li> </ul> <p>Keep your schemas tight and feature-specific\u2014don\u2019t overgeneralize prematurely.</p>"},{"location":"chapter9/#services-services","title":"Services \u2192 <code>/services/</code>","text":"<p>This is your business logic layer. It should:</p> <ul> <li>Be importable in tests</li> <li>Never access <code>Request</code>/<code>Response</code> objects directly</li> <li>Contain all GPT, OCR, or parsing logic per feature</li> </ul> <p>Example:</p> <pre><code># invoice/services/gpt_parser.py\ndef extract_invoice_data(text: str) -&gt; dict:\n    prompt = f\"Extract fields from: {text}\"\n    return call_gpt(prompt)\n</code></pre> <p>Avoid mixing API and service logic. Your services should feel pure.</p>"},{"location":"chapter9/#keeping-shared-logic-clean","title":"Keeping Shared Logic Clean","text":"<p>Not everything belongs to a feature. Common patterns include:</p> Shared Concern Location GPT clients &amp; config <code>shared/gpt/</code> OCR utilities <code>shared/ocr/</code> Database session, base models <code>shared/db/</code> Auth utilities <code>shared/auth/</code> Test fixtures <code>shared/test_helpers/</code> <p>If two or more modules use it, pull it out of the feature folder. Use <code>shared/</code> to avoid duplication and prevent coupling.</p>"},{"location":"chapter9/#handling-circular-imports","title":"Handling Circular Imports","text":"<p>Circular imports are a common pain in FastAPI modular design.</p>"},{"location":"chapter9/#problem","title":"Problem:","text":"<p><code>chatbot/services/gpt.py</code> imports <code>shared/gpt/client.py</code> but <code>client.py</code> also imports schema from <code>chatbot/schemas/</code></p>"},{"location":"chapter9/#solution","title":"Solution:","text":"<ul> <li>Never import feature-local files inside <code>shared/</code></li> <li>Move common schemas to <code>shared/schemas/</code> only if truly generic</li> <li>Use Dependency Injection to decouple layers</li> </ul>"},{"location":"chapter9/#structuring-testable-services","title":"Structuring Testable Services","text":"<p>Your <code>services/</code> should be:</p> <ul> <li>Importable without side effects</li> <li>Independent from actual external APIs (thanks to wrappers/mocks)</li> <li>Tested inside <code>__tests__/</code> per feature</li> </ul> <pre><code># chatbot/__tests__/test_streaming.py\n\nfrom chatbot.services.chat_service import stream_response\n\ndef test_stream_yields_valid_chunks():\n    payload = ChatRequest(message=\"Hi\")\n    chunks = list(stream_response(payload))\n    assert len(chunks) &gt; 0\n</code></pre> <p>Use <code>shared/test_helpers/</code> to store:</p> <ul> <li>Mock GPT/OpenAI clients</li> <li>Mock DB responses</li> <li>Test images for OCR</li> </ul>"},{"location":"chapter9/#dependency-injection-and-inversion","title":"Dependency Injection and Inversion","text":"<p>FastAPI\u2019s <code>Depends</code> is your secret weapon for modular testable code.</p> <p>Example:</p> <pre><code>def get_vector_db():\n    return SupabaseVectorStore()\n\n@router.post(\"/embed\")\ndef embed_doc(input: DocInput, db = Depends(get_vector_db)):\n    return db.add(input)\n</code></pre> <p>In tests:</p> <pre><code>def test_embed(monkeypatch):\n    monkeypatch.setattr(\"shared.vectorstore.get_vector_db\", lambda: MockVectorDB())\n</code></pre> <p>This keeps services decoupled and mockable, a key modularity goal.</p>"},{"location":"chapter9/#summary-modular-fastapi-guidelines","title":"Summary: Modular FastAPI Guidelines","text":"Principle Practice Feature-based foldering Each feature gets <code>api/</code>, <code>services/</code>, <code>schemas/</code> Keep routes thin All logic moves to services Local schemas Use per-feature Pydantic models Shared logic lives in <code>shared/</code> Only extract when multiple features need it Avoid circular imports Never import upwards; use DI patterns Local tests per module Use <code>__tests__/</code> to scope and scale testing"}]}